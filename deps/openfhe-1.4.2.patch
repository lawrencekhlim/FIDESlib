From b7ab08c17cc370d982395f8be1581946022bf8ff Mon Sep 17 00:00:00 2001
From: carlosad <carlos0105ad@gmail.com>
Date: Wed, 28 Jan 2026 11:43:03 +0100
Subject: [PATCH] Minimal Compatibility with FIDESlib

---
 CMakeLists.txt                                |   10 +-
 .../include/lattice/hal/default/dcrtpoly.h    |    1 +
 .../lattice/hal/default/ildcrtparams.h        |    3 +-
 src/core/include/lattice/hal/default/poly.h   |    2 +
 src/pke/include/cryptocontext.h               |    5 +-
 src/pke/include/encoding/plaintext.h          |    1 +
 src/pke/include/scheme/ckksrns/ckksrns-fhe.h  |   33 +-
 .../schemebase/base-cryptoparameters.h        |    3 +-
 src/pke/include/schemebase/base-fhe.h         |    2 +-
 src/pke/include/schemebase/base-scheme.h      |   15 +-
 .../include/schemerns/rns-cryptoparameters.h  |    4 +-
 src/pke/lib/cryptocontext.cpp                 |   27 +-
 src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp    | 1145 ++++++++++++++++-
 13 files changed, 1189 insertions(+), 62 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7cc5edc2..261f53a3 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -50,6 +50,8 @@ endif()
 
 message(STATUS "Building in ${CMAKE_BUILD_TYPE} mode")
 
+set(BUILD_STATIC ON)
+
 if (EMSCRIPTEN)
     set(BUILD_SHARED OFF)
     message("Shared library is not supported by Emscripten")
@@ -61,10 +63,10 @@ if (EMSCRIPTEN)
     message("OpenMP is not supported by Emscripten")
 else()
     option(BUILD_SHARED "Set to ON to build shared versions of the library"            ON  )
-    option(BUILD_STATIC "Set to ON to build static versions of the library"            OFF )
-    option(BUILD_UNITTESTS "Set to ON to build unit tests for the library"             ON  )
-    option(BUILD_EXAMPLES "Set to ON to build examples for the library"                ON  )
-    option(BUILD_BENCHMARKS "Set to ON to build benchmarks for the library"            ON  )
+    option(BUILD_STATIC "Set to ON to build static versions of the library"            ON )
+    option(BUILD_UNITTESTS "Set to ON to build unit tests for the library"             OFF  )
+    option(BUILD_EXAMPLES "Set to ON to build examples for the library"                OFF  )
+    option(BUILD_BENCHMARKS "Set to ON to build benchmarks for the library"            OFF  )
     option(WITH_OPENMP "Use OpenMP to enable <omp.h>"                                  ON  )
 endif()
 
diff --git a/src/core/include/lattice/hal/default/dcrtpoly.h b/src/core/include/lattice/hal/default/dcrtpoly.h
index 2cf18e26..d8b3fa10 100644
--- a/src/core/include/lattice/hal/default/dcrtpoly.h
+++ b/src/core/include/lattice/hal/default/dcrtpoly.h
@@ -392,6 +392,7 @@ public:
     }
 
 protected:
+public:
     std::shared_ptr<Params> m_params{std::make_shared<DCRTPolyImpl::Params>()};
     Format m_format{Format::EVALUATION};
     std::vector<PolyType> m_vectors;
diff --git a/src/core/include/lattice/hal/default/ildcrtparams.h b/src/core/include/lattice/hal/default/ildcrtparams.h
index cc15bc08..2ea846c3 100644
--- a/src/core/include/lattice/hal/default/ildcrtparams.h
+++ b/src/core/include/lattice/hal/default/ildcrtparams.h
@@ -362,7 +362,8 @@ protected:
         return out << std::endl;
     }
 
-private:
+//private:
+public:
     // array of smaller ILParams
     std::vector<std::shared_ptr<ILNativeParams>> m_params;
 };
diff --git a/src/core/include/lattice/hal/default/poly.h b/src/core/include/lattice/hal/default/poly.h
index 547cd992..12dc1163 100644
--- a/src/core/include/lattice/hal/default/poly.h
+++ b/src/core/include/lattice/hal/default/poly.h
@@ -364,8 +364,10 @@ public:
 
 protected:
     Format m_format{Format::EVALUATION};
+public:
     std::shared_ptr<Params> m_params{nullptr};
     std::unique_ptr<VecType> m_values{nullptr};
+protected:
     void ArbitrarySwitchFormat();
 };
 
diff --git a/src/pke/include/cryptocontext.h b/src/pke/include/cryptocontext.h
index 5837b515..817c4379 100644
--- a/src/pke/include/cryptocontext.h
+++ b/src/pke/include/cryptocontext.h
@@ -255,6 +255,7 @@ class CryptoContextImpl : public Serializable {
     static std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> GetPartialEvalAutomorphismKeyMapPtr(
         const std::string& keyTag, const std::vector<uint32_t>& indexList);
 
+public:
     // cached evalmult keys, by secret key UID
     static std::map<std::string, std::vector<EvalKey<Element>>> s_evalMultKeyMap;
     // cached evalautomorphism keys, by secret key UID
@@ -3573,8 +3574,8 @@ public:
     * @param precompute       Whether to precompute plaintexts for encoding/decoding.
     */
     void EvalBootstrapSetup(std::vector<uint32_t> levelBudget = {5, 4}, std::vector<uint32_t> dim1 = {0, 0},
-                            uint32_t slots = 0, uint32_t correctionFactor = 0, bool precompute = true) {
-        GetScheme()->EvalBootstrapSetup(*this, levelBudget, dim1, slots, correctionFactor, precompute);
+    uint32_t slots = 0, uint32_t correctionFactor = 0, bool precompute = true, int32_t modevallevels = -1) {
+                GetScheme()->EvalBootstrapSetup(*this, levelBudget, dim1, slots, correctionFactor, precompute, modevallevels);
     }
     /**
     * @brief Generates automorphism keys for EvalBootstrap. Uses baby-step/giant-step strategy. Supported only in CKKS.
diff --git a/src/pke/include/encoding/plaintext.h b/src/pke/include/encoding/plaintext.h
index 9548bb02..2eebe531 100644
--- a/src/pke/include/encoding/plaintext.h
+++ b/src/pke/include/encoding/plaintext.h
@@ -70,6 +70,7 @@ protected:
 
     Poly encodedVector;
     NativePoly encodedNativeVector;
+
     DCRTPoly encodedVectorDCRT;
 
     PlaintextEncodings ptxtEncoding{INVALID_ENCODING};
diff --git a/src/pke/include/scheme/ckksrns/ckksrns-fhe.h b/src/pke/include/scheme/ckksrns/ckksrns-fhe.h
index 233234e6..fdd022e2 100644
--- a/src/pke/include/scheme/ckksrns/ckksrns-fhe.h
+++ b/src/pke/include/scheme/ckksrns/ckksrns-fhe.h
@@ -127,12 +127,14 @@ using namespace std::literals::complex_literals;
 
 class FHECKKSRNS : public FHERNS {
 private:
+public:
     // correction factor, which we scale the message by to improve precision
     uint32_t m_correctionFactor;
 
     // key tuple is dim1, levelBudgetEnc, levelBudgetDec
-    std::map<uint32_t, std::shared_ptr<CKKSBootstrapPrecom>> m_bootPrecomMap;
 
+    std::map<uint32_t, std::shared_ptr<CKKSBootstrapPrecom>> m_bootPrecomMap;
+private:
     using ParmType = typename DCRTPoly::Params;
     using DugType  = typename DCRTPoly::DugType;
     using DggType  = typename DCRTPoly::DggType;
@@ -146,8 +148,17 @@ public:
     //------------------------------------------------------------------------------
 
     void EvalBootstrapSetup(const CryptoContextImpl<DCRTPoly>& cc, std::vector<uint32_t> levelBudget,
-                            std::vector<uint32_t> dim1, uint32_t slots, uint32_t correctionFactor,
-                            bool precompute) override;
+                            std::vector<uint32_t> dim1, uint32_t numSlots, uint32_t correctionFactor, bool precompute,
+                            uint32_t modevallevels = -1) override;
+
+    Ciphertext<DCRTPoly> EvalBootstrapNoStC(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                                        uint32_t precision) const;
+
+        std::pair<Ciphertext<DCRTPoly>, Ciphertext<DCRTPoly>> EvalBootstrapDensePartial(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                           uint32_t precision) const;
+
+        Ciphertext<DCRTPoly> EvalBootstrapSetupOnly(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                                                                        uint32_t precision) const;
 
     std::shared_ptr<std::map<uint32_t, EvalKey<DCRTPoly>>> EvalBootstrapKeyGen(const PrivateKey<DCRTPoly> privateKey,
                                                                                uint32_t slots) override;
@@ -225,12 +236,12 @@ public:
 
     std::vector<ReadOnlyPlaintext> EvalLinearTransformPrecompute(
         const CryptoContextImpl<DCRTPoly>& cc, const std::vector<std::vector<std::complex<double>>>& A,
-        double scale = 1., uint32_t L = 0) const;
+        double scale = 1., uint32_t L = 0, bool extended = true) const;
 
     std::vector<ReadOnlyPlaintext> EvalLinearTransformPrecompute(
         const CryptoContextImpl<DCRTPoly>& cc, const std::vector<std::vector<std::complex<double>>>& A,
         const std::vector<std::vector<std::complex<double>>>& B, uint32_t orientation = 0, double scale = 1,
-        uint32_t L = 0) const;
+        uint32_t L = 0, bool extended = true) const;
 
     std::vector<std::vector<ReadOnlyPlaintext>> EvalCoeffsToSlotsPrecompute(const CryptoContextImpl<DCRTPoly>& cc,
                                                                             const std::vector<std::complex<double>>& A,
@@ -312,8 +323,9 @@ private:
     //------------------------------------------------------------------------------
     // Find Rotation Indices
     //------------------------------------------------------------------------------
+public:
     std::vector<int32_t> FindBootstrapRotationIndices(uint32_t slots, uint32_t M);
-
+private:
     // ATTN: The following 3 functions are helper methods to be called in FindBootstrapRotationIndices() only.
     // so they DO NOT remove possible duplicates and automorphisms corresponding to 0 and M/4.
     // These methods completely depend on FindBootstrapRotationIndices() to do that.
@@ -333,9 +345,9 @@ private:
 
     void ExtendCiphertext(std::vector<DCRTPoly>& ciphertext, const CryptoContextImpl<DCRTPoly>& cc,
                           const std::shared_ptr<DCRTPoly::Params> params) const;
-
+public:
     void ApplyDoubleAngleIterations(Ciphertext<DCRTPoly>& ciphertext, uint32_t numIt) const;
-
+private:
     Plaintext MakeAuxPlaintext(const CryptoContextImpl<DCRTPoly>& cc, const std::shared_ptr<ParmType> params,
                                const std::vector<std::complex<double>>& value, size_t noiseScaleDeg, uint32_t level,
                                uint32_t slots) const;
@@ -346,11 +358,12 @@ private:
 
     Ciphertext<DCRTPoly> EvalAddExt(ConstCiphertext<DCRTPoly> ciphertext1, ConstCiphertext<DCRTPoly> ciphertext2) const;
 
+public:
     EvalKey<DCRTPoly> ConjugateKeyGen(const PrivateKey<DCRTPoly> privateKey) const;
 
     Ciphertext<DCRTPoly> Conjugate(ConstCiphertext<DCRTPoly> ciphertext,
                                    const std::map<uint32_t, EvalKey<DCRTPoly>>& evalKeys) const;
-
+private:
     /**
    * Set modulus and recalculates the vector values to fit the modulus
    *
@@ -400,7 +413,7 @@ private:
                                                    uint32_t digitBitSize, size_t order = 1);
 
     // upper bound for the number of overflows in the sparse secret case
-
+public:
     // TODO: unify this
     static constexpr uint32_t K_SPARSE     = 28;
     static constexpr uint32_t K_SPARSE_ALT = 25;
diff --git a/src/pke/include/schemebase/base-cryptoparameters.h b/src/pke/include/schemebase/base-cryptoparameters.h
index 23db5705..2d0f8632 100644
--- a/src/pke/include/schemebase/base-cryptoparameters.h
+++ b/src/pke/include/schemebase/base-cryptoparameters.h
@@ -224,8 +224,9 @@ protected:
     }
 
     // element-specific parameters
+public:
     std::shared_ptr<typename Element::Params> m_params;
-
+protected:
     // encoding-specific parameters
     EncodingParams m_encodingParams;
 };
diff --git a/src/pke/include/schemebase/base-fhe.h b/src/pke/include/schemebase/base-fhe.h
index ab267e52..30dc8ee7 100644
--- a/src/pke/include/schemebase/base-fhe.h
+++ b/src/pke/include/schemebase/base-fhe.h
@@ -84,7 +84,7 @@ public:
    */
     virtual void EvalBootstrapSetup(const CryptoContextImpl<Element>& cc, std::vector<uint32_t> levelBudget,
                                     std::vector<uint32_t> dim1, uint32_t slots, uint32_t correctionFactor,
-                                    bool precompute) {
+                                    bool precompute, uint32_t modevallevels = -1) {
         OPENFHE_THROW("Not supported");
     }
 
diff --git a/src/pke/include/schemebase/base-scheme.h b/src/pke/include/schemebase/base-scheme.h
index d735ad95..65925705 100644
--- a/src/pke/include/schemebase/base-scheme.h
+++ b/src/pke/include/schemebase/base-scheme.h
@@ -46,6 +46,7 @@
 #include "schemebase/base-pre.h"
 #include "utils/caller_info.h"
 #include "utils/exception.h"
+#include "scheme/ckksrns/ckksrns-fhe.h"
 
 #include <map>
 #include <memory>
@@ -1141,9 +1142,9 @@ public:
 
     void EvalBootstrapSetup(const CryptoContextImpl<Element>& cc, const std::vector<uint32_t>& levelBudget = {5, 4},
                             const std::vector<uint32_t>& dim1 = {0, 0}, uint32_t slots = 0,
-                            uint32_t correctionFactor = 0, bool precompute = true) {
+                            uint32_t correctionFactor = 0, bool precompute = true, int32_t modevallevels = -1) {
         VerifyFHEEnabled(__func__);
-        m_FHE->EvalBootstrapSetup(cc, levelBudget, dim1, slots, correctionFactor, precompute);
+        m_FHE->EvalBootstrapSetup(cc, levelBudget, dim1, slots, correctionFactor, precompute, modevallevels);
     }
 
     std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> EvalBootstrapKeyGen(const PrivateKey<Element> privateKey,
@@ -1163,6 +1164,14 @@ public:
         return m_FHE->EvalBootstrap(ciphertext, numIterations, precision);
     }
 
+    std::pair<Ciphertext<Element>, Ciphertext<Element>>
+            EvalBootstrapDensePartial(ConstCiphertext<Element> ciphertext, uint32_t numIterations = 1,
+                                      uint32_t precision = 0) const {
+                VerifyFHEEnabled(__func__);
+
+                return dynamic_cast<lbcrypto::FHECKKSRNS *>(m_FHE.get())->EvalBootstrapDensePartial(ciphertext, numIterations, precision);
+        }
+
     template <typename VectorDataType>
     void EvalFBTSetup(const CryptoContextImpl<Element>& cc, const std::vector<VectorDataType>& coeffs,
                       uint32_t numSlots, const BigInteger& PIn, const BigInteger& POut, const BigInteger& Bigq,
@@ -1540,7 +1549,9 @@ protected:
     std::shared_ptr<LeveledSHEBase<Element>> m_LeveledSHE;
     std::shared_ptr<AdvancedSHEBase<Element>> m_AdvancedSHE;
     std::shared_ptr<MultipartyBase<Element>> m_Multiparty;
+public:
     std::shared_ptr<FHEBase<Element>> m_FHE;
+protected:
     std::shared_ptr<FHEBase<Element>> m_SchemeSwitch;
 
     inline void CheckMultipartyDecryptCompatibility(ConstCiphertext<Element>& ciphertext, CALLER_INFO_ARGS_HDR) const {
diff --git a/src/pke/include/schemerns/rns-cryptoparameters.h b/src/pke/include/schemerns/rns-cryptoparameters.h
index 948ba1a1..272f7bd0 100644
--- a/src/pke/include/schemerns/rns-cryptoparameters.h
+++ b/src/pke/include/schemerns/rns-cryptoparameters.h
@@ -1418,7 +1418,7 @@ protected:
     /////////////////////////////////////
     // BGVrns ModReduce
     /////////////////////////////////////
-
+public:
     // Stores NTL precomputations for [t]_{q_i}
     std::vector<NativeInteger> m_tModqPrecon;
 
@@ -1530,7 +1530,6 @@ protected:
 
     // Stores 2^ptm where ptm - plaintext modulus
     double m_approxSF = 0;
-
     /////////////////////////////////////
     // CKKS RNS Composite Scaling Params
     /////////////////////////////////////
@@ -1552,6 +1551,7 @@ protected:
 
     NativeInteger m_fixedSF = NativeInteger(1);
 
+protected:
     /////////////////////////////////////
     // BFVrns : Encrypt
     /////////////////////////////////////
diff --git a/src/pke/lib/cryptocontext.cpp b/src/pke/lib/cryptocontext.cpp
index fe26edc9..aaee034d 100644
--- a/src/pke/lib/cryptocontext.cpp
+++ b/src/pke/lib/cryptocontext.cpp
@@ -36,7 +36,7 @@
 #include "cryptocontext.h"
 #include "key/privatekey.h"
 #include "key/publickey.h"
-#include "math/chebyshev.h"
+//#include "math/chebyshev.h"
 #include "scheme/ckksrns/ckksrns-cryptoparameters.h"
 #include "schemerns/rns-scheme.h"
 
@@ -493,11 +493,34 @@ DecryptResult CryptoContextImpl<Element>::Decrypt(ConstCiphertext<Element>& ciph
 // Advanced SHE CHEBYSHEV SERIES EXAMPLES
 //------------------------------------------------------------------------------
 
+/** Static linking does not find this function's implementation in core/math/chebyshev.cpp */
+std::vector<double> EvalChebyshevCoefficients(std::function<double(double)> func, double a, double b, uint32_t degree) {
+    if (degree == 0)
+        OPENFHE_THROW("The degree of approximation can not be zero");
+    // the number of coefficients to be generated should be degree+1 as zero is also included
+    size_t coeffTotal{degree + 1};
+    double bMinusA = 0.5 * (b - a);
+    double bPlusA  = 0.5 * (b + a);
+    double PiByDeg = M_PI / static_cast<double>(coeffTotal);
+    std::vector<double> functionPoints(coeffTotal);
+    for (size_t i = 0; i < coeffTotal; ++i)
+        functionPoints[i] = func(std::cos(PiByDeg * (i + 0.5)) * bMinusA + bPlusA);
+
+    double multFactor = 2.0 / static_cast<double>(coeffTotal);
+    std::vector<double> coefficients(coeffTotal);
+    for (size_t i = 0; i < coeffTotal; ++i) {
+        for (size_t j = 0; j < coeffTotal; ++j)
+            coefficients[i] += functionPoints[j] * std::cos(PiByDeg * i * (j + 0.5));
+        coefficients[i] *= multFactor;
+    }
+    return coefficients;
+}
+
 template <typename Element>
 Ciphertext<Element> CryptoContextImpl<Element>::EvalChebyshevFunction(std::function<double(double)> func,
                                                                       ConstCiphertext<Element>& ciphertext, double a,
                                                                       double b, uint32_t degree) const {
-    std::vector<double> coefficients = EvalChebyshevCoefficients(func, a, b, degree);
+    std::vector<double> coefficients = lbcrypto::EvalChebyshevCoefficients(func, a, b, degree);
     return EvalChebyshevSeries(ciphertext, coefficients, a, b);
 }
 
diff --git a/src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp b/src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp
index c895b3e3..4e1e9f82 100644
--- a/src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp
+++ b/src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp
@@ -84,7 +84,7 @@ namespace lbcrypto {
 
 void FHECKKSRNS::EvalBootstrapSetup(const CryptoContextImpl<DCRTPoly>& cc, std::vector<uint32_t> levelBudget,
                                     std::vector<uint32_t> dim1, uint32_t numSlots, uint32_t correctionFactor,
-                                    bool precompute) {
+                                    bool precompute, uint32_t modevallevels) {
     const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(cc.GetCryptoParameters());
 
     if (cryptoParams->GetKeySwitchTechnique() != HYBRID)
@@ -195,52 +195,1107 @@ void FHECKKSRNS::EvalBootstrapSetup(const CryptoContextImpl<DCRTPoly>& cc, std::
         // TODO: YSP Can be extended to FLEXIBLE* scaling techniques as well as the closeness of 2^p to moduli is no longer needed
         double scaleDec = (compositeDegree > 1) ? qDouble / cryptoParams->GetScalingFactorReal(0) : 1.0 / pre;
 
-        uint32_t approxModDepth = GetModDepthInternal(cryptoParams->GetSecretKeyDist());
+        //uint32_t approxModDepth = GetModDepthInternal(cryptoParams->GetSecretKeyDist());
+        uint32_t approxModDepth = modevallevels == (uint32_t)-1 ? GetModDepthInternal(cryptoParams->GetSecretKeyDist()) : modevallevels;
+        uint32_t depthBT = approxModDepth + precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] +
+                           precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET];
+
+        // compute # of levels to remain when encoding the coefficients
+        // for FLEXIBLEAUTOEXT we do not need extra modulus in auxiliary plaintexts
+        auto st     = cryptoParams->GetScalingTechnique();
+        uint32_t L0 = cryptoParams->GetElementParams()->GetParams().size() - (st == FLEXIBLEAUTOEXT);
+
+        uint32_t lEnc = L0 - compositeDegree * (precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] + 1);
+        uint32_t lDec = L0 - compositeDegree * depthBT;
+
+        bool isLTBootstrap = (precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1) &&
+                             (precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1);
+
+        if (isLTBootstrap) {
+            // allocate all vectors
+            std::vector<std::vector<std::complex<double>>> U0(slots, std::vector<std::complex<double>>(slots));
+            std::vector<std::vector<std::complex<double>>> U1(slots, std::vector<std::complex<double>>(slots));
+            std::vector<std::vector<std::complex<double>>> U0hatT(slots, std::vector<std::complex<double>>(slots));
+            std::vector<std::vector<std::complex<double>>> U1hatT(slots, std::vector<std::complex<double>>(slots));
+
+            for (uint32_t i = 0; i < slots; i++) {
+                for (uint32_t j = 0; j < slots; j++) {
+                    U0[i][j]     = ksiPows[(j * rotGroup[i]) & mmask];
+                    U0hatT[j][i] = std::conj(U0[i][j]);
+                    U1[i][j]     = std::complex<double>(0, 1) * U0[i][j];
+                    U1hatT[j][i] = std::conj(U1[i][j]);
+                }
+            }
+
+            if (!isSparse) {
+                precom->m_U0hatTPre = EvalLinearTransformPrecompute(cc, U0hatT, scaleEnc, lEnc);
+                precom->m_U0Pre     = EvalLinearTransformPrecompute(cc, U0, scaleDec, lDec);
+            }
+            else {
+                precom->m_U0hatTPre = EvalLinearTransformPrecompute(cc, U0hatT, U1hatT, 0, scaleEnc, lEnc);
+                precom->m_U0Pre     = EvalLinearTransformPrecompute(cc, U0, U1, 1, scaleDec, lDec);
+            }
+        }
+        else {
+            precom->m_U0hatTPreFFT = EvalCoeffsToSlotsPrecompute(cc, ksiPows, rotGroup, false, scaleEnc, lEnc);
+            precom->m_U0PreFFT     = EvalSlotsToCoeffsPrecompute(cc, ksiPows, rotGroup, false, scaleDec, lDec);
+        }
+    }
+}
+
+Ciphertext<DCRTPoly> FHECKKSRNS::EvalBootstrapSetupOnly(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                            uint32_t precision) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ciphertext->GetCryptoParameters());
+
+    if (cryptoParams->GetKeySwitchTechnique() != HYBRID)
+        OPENFHE_THROW("CKKS Bootstrapping is only supported for the Hybrid key switching method.");
+#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTO || cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT)
+        OPENFHE_THROW("128-bit CKKS Bootstrapping is supported for FIXEDMANUAL and FIXEDAUTO methods only.");
+#endif
+    if (numIterations != 1 && numIterations != 2) {
+        OPENFHE_THROW("CKKS Iterative Bootstrapping is only supported for 1 or 2 iterations.");
+    }
+
+#ifdef BOOTSTRAPTIMING
+    TimeVar t;
+    double timeEncode(0.0);
+    double timeModReduce(0.0);
+    double timeDecode(0.0);
+#endif
+
+    auto cc        = ciphertext->GetCryptoContext();
+    uint32_t M     = cc->GetCyclotomicOrder();
+    uint32_t L0    = cryptoParams->GetElementParams()->GetParams().size();
+    auto initSizeQ = ciphertext->GetElements()[0].GetNumOfElements();
+
+    if (numIterations > 1) {
+        // Step 1: Get the input.
+        uint32_t powerOfTwoModulus = 1 << precision;
+
+        // Step 2: Scale up by powerOfTwoModulus, and extend the modulus to powerOfTwoModulus * q.
+        // Note that we extend the modulus implicitly without any code calls because the value always stays 0.
+        Ciphertext<DCRTPoly> ctScaledUp = ciphertext->Clone();
+        // We multiply by powerOfTwoModulus, and leave the last CRT value to be 0 (mod powerOfTwoModulus).
+        cc->GetScheme()->MultByIntegerInPlace(ctScaledUp, powerOfTwoModulus);
+        ctScaledUp->SetLevel(L0 - ctScaledUp->GetElements()[0].GetNumOfElements());
+
+        // Step 3: Bootstrap the initial ciphertext.
+        auto ctInitialBootstrap = cc->EvalBootstrap(ciphertext, numIterations - 1, precision);
+        cc->GetScheme()->ModReduceInternalInPlace(ctInitialBootstrap, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 4: Scale up by powerOfTwoModulus.
+        cc->GetScheme()->MultByIntegerInPlace(ctInitialBootstrap, powerOfTwoModulus);
+
+        // Step 5: Mod-down to powerOfTwoModulus * q
+        // We mod down, and leave the last CRT value to be 0 because it's divisible by powerOfTwoModulus.
+        auto ctBootstrappedScaledDown = ctInitialBootstrap->Clone();
+        auto bootstrappingSizeQ       = ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements();
+
+        // If we start with more towers, than we obtain from bootstrapping, return the original ciphertext.
+        if (bootstrappingSizeQ <= initSizeQ) {
+            return ciphertext->Clone();
+        }
+        for (auto& cv : ctBootstrappedScaledDown->GetElements()) {
+            cv.DropLastElements(bootstrappingSizeQ - initSizeQ);
+        }
+        ctBootstrappedScaledDown->SetLevel(L0 - ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements());
+
+        // Step 6 and 7: Calculate the bootstrapping error by subtracting the original ciphertext from the bootstrapped ciphertext. Mod down to q is done implicitly.
+        auto ctBootstrappingError = cc->EvalSub(ctBootstrappedScaledDown, ctScaledUp);
+
+        // Step 8: Bootstrap the error.
+        auto ctBootstrappedError = cc->EvalBootstrap(ctBootstrappingError, 1, 0);
+        cc->GetScheme()->ModReduceInternalInPlace(ctBootstrappedError, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 9: Subtract the bootstrapped error from the initial bootstrap to get even lower error.
+        auto finalCiphertext = cc->EvalSub(ctInitialBootstrap, ctBootstrappedError);
+
+        // Step 10: Scale back down by powerOfTwoModulus to get the original message.
+        cc->EvalMultInPlace(finalCiphertext, static_cast<double>(1) / powerOfTwoModulus);
+        return finalCiphertext;
+    }
+
+    uint32_t slots = ciphertext->GetSlots();
+
+    auto pair = m_bootPrecomMap.find(slots);
+    if (pair == m_bootPrecomMap.end()) {
+        std::string errorMsg(std::string("Precomputations for ") + std::to_string(slots) +
+                             std::string(" slots were not generated") +
+                             std::string(" Need to call EvalBootstrapSetup and then EvalBootstrapKeyGen to proceed"));
+        OPENFHE_THROW(errorMsg);
+    }
+    const std::shared_ptr<CKKSBootstrapPrecom> precom = pair->second;
+    size_t N                                          = cc->GetRingDimension();
+
+    auto elementParamsRaised = *(cryptoParams->GetElementParams());
+
+    // For FLEXIBLEAUTOEXT we raised ciphertext does not include extra modulus
+    // as it is multiplied by auxiliary plaintext
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT) {
+        elementParamsRaised.PopLastParam();
+    }
+
+    auto paramsQ = elementParamsRaised.GetParams();
+    usint sizeQ  = paramsQ.size();
+
+    std::vector<NativeInteger> moduli(sizeQ);
+    std::vector<NativeInteger> roots(sizeQ);
+    for (size_t i = 0; i < sizeQ; i++) {
+        moduli[i] = paramsQ[i]->GetModulus();
+        roots[i]  = paramsQ[i]->GetRootOfUnity();
+    }
+    auto elementParamsRaisedPtr = std::make_shared<ILDCRTParams<DCRTPoly::Integer>>(M, moduli, roots);
+
+    NativeInteger q = elementParamsRaisedPtr->GetParams()[0]->GetModulus().ConvertToInt();
+    double qDouble  = q.ConvertToDouble();
+
+    const auto p = cryptoParams->GetPlaintextModulus();
+    double powP  = pow(2, p);
+
+    int32_t deg = std::round(std::log2(qDouble / powP));
+#if NATIVEINT != 128
+    if (deg > static_cast<int32_t>(m_correctionFactor)) {
+        OPENFHE_THROW("Degree [" + std::to_string(deg) + "] must be less than or equal to the correction factor [" +
+                      std::to_string(m_correctionFactor) + "].");
+    }
+#endif
+    uint32_t correction = m_correctionFactor - deg;
+    double post         = std::pow(2, static_cast<double>(deg));
+
+    double pre      = 1. / post;
+    uint64_t scalar = std::llround(post);
+
+    //------------------------------------------------------------------------------
+    // RAISING THE MODULUS
+    //------------------------------------------------------------------------------
+
+    // In FLEXIBLEAUTO, raising the ciphertext to a larger number
+    // of towers is a bit more complex, because we need to adjust
+    // it's scaling factor to the one that corresponds to the level
+    // it's being raised to.
+    // Increasing the modulus
+
+    Ciphertext<DCRTPoly> raised = ciphertext->Clone();
+    auto algo                   = cc->GetScheme();
+    algo->ModReduceInternalInPlace(raised, raised->GetNoiseScaleDeg() - 1);
+
+    AdjustCiphertext(raised, correction);
+    auto ctxtDCRT = raised->GetElements();
+
+    // We only use the level 0 ciphertext here. All other towers are automatically ignored to make
+    // CKKS bootstrapping faster.
+    for (size_t i = 0; i < ctxtDCRT.size(); i++) {
+        DCRTPoly temp(elementParamsRaisedPtr, COEFFICIENT);
+        ctxtDCRT[i].SetFormat(COEFFICIENT);
+        temp = ctxtDCRT[i].GetElementAtIndex(0);
+        temp.SetFormat(EVALUATION);
+        ctxtDCRT[i] = temp;
+    }
+
+    raised->SetElements(ctxtDCRT);
+    raised->SetLevel(L0 - ctxtDCRT[0].GetNumOfElements());
+
+#ifdef BOOTSTRAPTIMING
+    std::cerr << "\nNumber of levels at the beginning of bootstrapping: "
+              << raised->GetElements()[0].GetNumOfElements() - 1 << std::endl;
+#endif
+
+    //------------------------------------------------------------------------------
+    // SETTING PARAMETERS FOR APPROXIMATE MODULAR REDUCTION
+    //------------------------------------------------------------------------------
+
+    // Coefficients of the Chebyshev series interpolating 1/(2 Pi) Sin(2 Pi K x)
+    std::vector<double> coefficients;
+    double k = 0;
+
+    if (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY) {
+        coefficients = g_coefficientsSparse;
+        // k = K_SPARSE;
+        k = 1.0;  // do not divide by k as we already did it during precomputation
+    }
+    else {
+        coefficients = g_coefficientsUniform;
+        k            = K_UNIFORM;
+    }
+
+    double constantEvalMult = pre * (1.0 / (k * N));
+
+    cc->EvalMultInPlace(raised, constantEvalMult);
+
+    // no linear transformations are needed for Chebyshev series as the range has been normalized to [-1,1]
+    double coeffLowerBound = -1;
+    double coeffUpperBound = 1;
+
+    Ciphertext<DCRTPoly> ctxtDec;
+
+    bool isLTBootstrap = (precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1) &&
+                         (precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1);
+    if (slots == M / 4) {
+        //------------------------------------------------------------------------------
+        // FULLY PACKED CASE
+        //------------------------------------------------------------------------------
+
+#ifdef BOOTSTRAPTIMING
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running CoeffToSlot
+        //------------------------------------------------------------------------------
+
+        // need to call internal modular reduction so it also works for FLEXIBLEAUTO
+        algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
+
+        return raised;
+        // only one linear transform is needed as the other one can be derived
+        auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
+                                         EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
+
+        auto evalKeyMap = cc->GetEvalAutomorphismKeyMap(ctxtEnc->GetKeyTag());
+        auto conj       = Conjugate(ctxtEnc, evalKeyMap);
+        auto ctxtEncI   = cc->EvalSub(ctxtEnc, conj);
+        cc->EvalAddInPlace(ctxtEnc, conj);
+        algo->MultByMonomialInPlace(ctxtEncI, 3 * M / 4);
+
+        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+            while (ctxtEnc->GetNoiseScaleDeg() > 1) {
+                cc->ModReduceInPlace(ctxtEnc);
+                cc->ModReduceInPlace(ctxtEncI);
+            }
+        }
+        else {
+            if (ctxtEnc->GetNoiseScaleDeg() == 2) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+                algo->ModReduceInternalInPlace(ctxtEncI, BASE_NUM_LEVELS_TO_DROP);
+            }
+        }
+
+        //------------------------------------------------------------------------------
+        // Running Approximate Mod Reduction
+        //------------------------------------------------------------------------------
+
+        // Evaluate Chebyshev series for the sine wave
+        ctxtEnc  = cc->EvalChebyshevSeries(ctxtEnc, coefficients, coeffLowerBound, coeffUpperBound);
+        ctxtEncI = cc->EvalChebyshevSeries(ctxtEncI, coefficients, coeffLowerBound, coeffUpperBound);
+
+        // Double-angle iterations
+        if ((cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY) ||
+            (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY)) {
+            if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+                algo->ModReduceInternalInPlace(ctxtEncI, BASE_NUM_LEVELS_TO_DROP);
+            }
+            uint32_t numIter;
+            if (cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY)
+                numIter = R_UNIFORM;
+            else
+                numIter = R_SPARSE;
+            ApplyDoubleAngleIterations(ctxtEnc, numIter);
+            ApplyDoubleAngleIterations(ctxtEncI, numIter);
+        }
+
+        algo->MultByMonomialInPlace(ctxtEncI, M / 4);
+        cc->EvalAddInPlace(ctxtEnc, ctxtEncI);
+
+        // scale the message back up after Chebyshev interpolation
+        algo->MultByIntegerInPlace(ctxtEnc, scalar);
+
+#ifdef BOOTSTRAPTIMING
+        timeModReduce = TOC(t);
+
+        std::cerr << "Approximate modular reduction time: " << timeModReduce / 1000.0 << " s" << std::endl;
+
+        // Running SlotToCoeff
+
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running SlotToCoeff
+        //------------------------------------------------------------------------------
+
+        // In the case of FLEXIBLEAUTO, we need one extra tower
+        // TODO: See if we can remove the extra level in FLEXIBLEAUTO
+        if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+            algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+        }
+
+        // Only one linear transform is needed
+        ctxtDec = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0Pre, ctxtEnc) :
+                                    EvalSlotsToCoeffs(precom->m_U0PreFFT, ctxtEnc);
+    }
+    else {
+        //------------------------------------------------------------------------------
+        // SPARSELY PACKED CASE
+        //------------------------------------------------------------------------------
+
+        //------------------------------------------------------------------------------
+        // Running PartialSum
+        //------------------------------------------------------------------------------
+
+        for (uint32_t j = 1; j < N / (2 * slots); j <<= 1) {
+            auto temp = cc->EvalRotate(raised, j * slots);
+            cc->EvalAddInPlace(raised, temp);
+        }
+
+#ifdef BOOTSTRAPTIMING
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running CoeffsToSlots
+        //------------------------------------------------------------------------------
+
+        algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
+
+        return raised;
+
+        auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
+                                         EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
+
+        auto evalKeyMap = cc->GetEvalAutomorphismKeyMap(ctxtEnc->GetKeyTag());
+        auto conj       = Conjugate(ctxtEnc, evalKeyMap);
+        cc->EvalAddInPlace(ctxtEnc, conj);
+
+        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+            while (ctxtEnc->GetNoiseScaleDeg() > 1) {
+                cc->ModReduceInPlace(ctxtEnc);
+            }
+        }
+        else {
+            if (ctxtEnc->GetNoiseScaleDeg() == 2) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+            }
+        }
+
+#ifdef BOOTSTRAPTIMING
+        timeEncode = TOC(t);
+
+        std::cerr << "\nEncoding time: " << timeEncode / 1000.0 << " s" << std::endl;
+
+        // Running Approximate Mod Reduction
+
+        TIC(t);
+#endif
+
+        return ctxtEnc;
+        //------------------------------------------------------------------------------
+        // Running Approximate Mod Reduction
+        //------------------------------------------------------------------------------
+
+        // Evaluate Chebyshev series for the sine wave
+        ctxtEnc = cc->EvalChebyshevSeries(ctxtEnc, coefficients, coeffLowerBound, coeffUpperBound);
+
+        // Double-angle iterations
+        if ((cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY) ||
+            (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY)) {
+            if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+            }
+            uint32_t numIter;
+            if (cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY)
+                numIter = R_UNIFORM;
+            else
+                numIter = R_SPARSE;
+            ApplyDoubleAngleIterations(ctxtEnc, numIter);
+        }
+
+        // scale the message back up after Chebyshev interpolation
+        algo->MultByIntegerInPlace(ctxtEnc, scalar);
+
+#ifdef BOOTSTRAPTIMING
+        timeModReduce = TOC(t);
+
+        std::cerr << "Approximate modular reduction time: " << timeModReduce / 1000.0 << " s" << std::endl;
+
+        // Running SlotToCoeff
+
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running SlotsToCoeffs
+        //------------------------------------------------------------------------------
+
+        // In the case of FLEXIBLEAUTO, we need one extra tower
+        // TODO: See if we can remove the extra level in FLEXIBLEAUTO
+        if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+            algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+        }
+
+        // linear transform for decoding
+        ctxtDec = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0Pre, ctxtEnc) :
+                                    EvalSlotsToCoeffs(precom->m_U0PreFFT, ctxtEnc);
+
+        cc->EvalAddInPlace(ctxtDec, cc->EvalRotate(ctxtDec, slots));
+    }
+
+#if NATIVEINT != 128
+    // 64-bit only: scale back the message to its original scale.
+    uint64_t corFactor = (uint64_t)1 << std::llround(correction);
+    algo->MultByIntegerInPlace(ctxtDec, corFactor);
+#endif
+
+#ifdef BOOTSTRAPTIMING
+    timeDecode = TOC(t);
+
+    std::cout << "Decoding time: " << timeDecode / 1000.0 << " s" << std::endl;
+#endif
+
+    auto bootstrappingNumTowers = ctxtDec->GetElements()[0].GetNumOfElements();
+
+    // If we start with more towers, than we obtain from bootstrapping, return the original ciphertext.
+    if (bootstrappingNumTowers <= initSizeQ) {
+        return ciphertext->Clone();
+    }
+
+    return ctxtDec;
+}
+
+std::pair<Ciphertext<DCRTPoly>, Ciphertext<DCRTPoly>>  FHECKKSRNS::EvalBootstrapDensePartial(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                               uint32_t precision) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ciphertext->GetCryptoParameters());
+
+    if (cryptoParams->GetKeySwitchTechnique() != HYBRID)
+        OPENFHE_THROW("CKKS Bootstrapping is only supported for the Hybrid key switching method.");
+#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTO || cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT)
+        OPENFHE_THROW("128-bit CKKS Bootstrapping is supported for FIXEDMANUAL and FIXEDAUTO methods only.");
+#endif
+    if (numIterations != 1 && numIterations != 2) {
+        OPENFHE_THROW("CKKS Iterative Bootstrapping is only supported for 1 or 2 iterations.");
+    }
+
+#ifdef BOOTSTRAPTIMING
+    TimeVar t;
+    double timeEncode(0.0);
+    double timeModReduce(0.0);
+    double timeDecode(0.0);
+#endif
+
+    auto cc        = ciphertext->GetCryptoContext();
+    uint32_t M     = cc->GetCyclotomicOrder();
+    uint32_t L0    = cryptoParams->GetElementParams()->GetParams().size();
+    auto initSizeQ = ciphertext->GetElements()[0].GetNumOfElements();
+
+    if (numIterations > 1) {
+        // Step 1: Get the input.
+        uint32_t powerOfTwoModulus = 1 << precision;
+
+        // Step 2: Scale up by powerOfTwoModulus, and extend the modulus to powerOfTwoModulus * q.
+        // Note that we extend the modulus implicitly without any code calls because the value always stays 0.
+        Ciphertext<DCRTPoly> ctScaledUp = ciphertext->Clone();
+        // We multiply by powerOfTwoModulus, and leave the last CRT value to be 0 (mod powerOfTwoModulus).
+        cc->GetScheme()->MultByIntegerInPlace(ctScaledUp, powerOfTwoModulus);
+        ctScaledUp->SetLevel(L0 - ctScaledUp->GetElements()[0].GetNumOfElements());
+
+        // Step 3: Bootstrap the initial ciphertext.
+        auto ctInitialBootstrap = cc->EvalBootstrap(ciphertext, numIterations - 1, precision);
+        cc->GetScheme()->ModReduceInternalInPlace(ctInitialBootstrap, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 4: Scale up by powerOfTwoModulus.
+        cc->GetScheme()->MultByIntegerInPlace(ctInitialBootstrap, powerOfTwoModulus);
+
+        // Step 5: Mod-down to powerOfTwoModulus * q
+        // We mod down, and leave the last CRT value to be 0 because it's divisible by powerOfTwoModulus.
+        auto ctBootstrappedScaledDown = ctInitialBootstrap->Clone();
+        auto bootstrappingSizeQ       = ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements();
+
+        // If we start with more towers, than we obtain from bootstrapping, return the original ciphertext.
+        if (bootstrappingSizeQ <= initSizeQ) {
+            //return ciphertext->Clone();
+        }
+        for (auto& cv : ctBootstrappedScaledDown->GetElements()) {
+            cv.DropLastElements(bootstrappingSizeQ - initSizeQ);
+        }
+        ctBootstrappedScaledDown->SetLevel(L0 - ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements());
+
+        // Step 6 and 7: Calculate the bootstrapping error by subtracting the original ciphertext from the bootstrapped ciphertext. Mod down to q is done implicitly.
+        auto ctBootstrappingError = cc->EvalSub(ctBootstrappedScaledDown, ctScaledUp);
+
+        // Step 8: Bootstrap the error.
+        auto ctBootstrappedError = cc->EvalBootstrap(ctBootstrappingError, 1, 0);
+        cc->GetScheme()->ModReduceInternalInPlace(ctBootstrappedError, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 9: Subtract the bootstrapped error from the initial bootstrap to get even lower error.
+        auto finalCiphertext = cc->EvalSub(ctInitialBootstrap, ctBootstrappedError);
+
+        // Step 10: Scale back down by powerOfTwoModulus to get the original message.
+        cc->EvalMultInPlace(finalCiphertext, static_cast<double>(1) / powerOfTwoModulus);
+        //return finalCiphertext;
+    }
+
+    uint32_t slots = ciphertext->GetSlots();
+
+    auto pair = m_bootPrecomMap.find(slots);
+    if (pair == m_bootPrecomMap.end()) {
+        std::string errorMsg(std::string("Precomputations for ") + std::to_string(slots) +
+                             std::string(" slots were not generated") +
+                             std::string(" Need to call EvalBootstrapSetup and then EvalBootstrapKeyGen to proceed"));
+        OPENFHE_THROW(errorMsg);
+    }
+    const std::shared_ptr<CKKSBootstrapPrecom> precom = pair->second;
+    size_t N                                          = cc->GetRingDimension();
+
+    auto elementParamsRaised = *(cryptoParams->GetElementParams());
+
+    // For FLEXIBLEAUTOEXT we raised ciphertext does not include extra modulus
+    // as it is multiplied by auxiliary plaintext
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT) {
+        elementParamsRaised.PopLastParam();
+    }
+
+    auto paramsQ = elementParamsRaised.GetParams();
+    usint sizeQ  = paramsQ.size();
+
+    std::vector<NativeInteger> moduli(sizeQ);
+    std::vector<NativeInteger> roots(sizeQ);
+    for (size_t i = 0; i < sizeQ; i++) {
+        moduli[i] = paramsQ[i]->GetModulus();
+        roots[i]  = paramsQ[i]->GetRootOfUnity();
+    }
+    auto elementParamsRaisedPtr = std::make_shared<ILDCRTParams<DCRTPoly::Integer>>(M, moduli, roots);
+
+    NativeInteger q = elementParamsRaisedPtr->GetParams()[0]->GetModulus().ConvertToInt();
+    double qDouble  = q.ConvertToDouble();
+
+    const auto p = cryptoParams->GetPlaintextModulus();
+    double powP  = pow(2, p);
+
+    int32_t deg = std::round(std::log2(qDouble / powP));
+#if NATIVEINT != 128
+    if (deg > static_cast<int32_t>(m_correctionFactor)) {
+        OPENFHE_THROW("Degree [" + std::to_string(deg) + "] must be less than or equal to the correction factor [" +
+                      std::to_string(m_correctionFactor) + "].");
+    }
+#endif
+    uint32_t correction = m_correctionFactor - deg;
+    double post         = std::pow(2, static_cast<double>(deg));
+
+    double pre      = 1. / post;
+    //uint64_t scalar = std::llround(post);
+
+    //------------------------------------------------------------------------------
+    // RAISING THE MODULUS
+    //------------------------------------------------------------------------------
+
+    // In FLEXIBLEAUTO, raising the ciphertext to a larger number
+    // of towers is a bit more complex, because we need to adjust
+    // it's scaling factor to the one that corresponds to the level
+    // it's being raised to.
+    // Increasing the modulus
+
+    Ciphertext<DCRTPoly> raised = ciphertext->Clone();
+    auto algo                   = cc->GetScheme();
+    algo->ModReduceInternalInPlace(raised, raised->GetNoiseScaleDeg() - 1);
+
+    AdjustCiphertext(raised, correction);
+    auto ctxtDCRT = raised->GetElements();
+
+    // We only use the level 0 ciphertext here. All other towers are automatically ignored to make
+    // CKKS bootstrapping faster.
+    for (size_t i = 0; i < ctxtDCRT.size(); i++) {
+        DCRTPoly temp(elementParamsRaisedPtr, COEFFICIENT);
+        ctxtDCRT[i].SetFormat(COEFFICIENT);
+        temp = ctxtDCRT[i].GetElementAtIndex(0);
+        temp.SetFormat(EVALUATION);
+        ctxtDCRT[i] = temp;
+    }
+
+    raised->SetElements(ctxtDCRT);
+    raised->SetLevel(L0 - ctxtDCRT[0].GetNumOfElements());
+
+#ifdef BOOTSTRAPTIMING
+    std::cerr << "\nNumber of levels at the beginning of bootstrapping: "
+              << raised->GetElements()[0].GetNumOfElements() - 1 << std::endl;
+#endif
+
+    //------------------------------------------------------------------------------
+    // SETTING PARAMETERS FOR APPROXIMATE MODULAR REDUCTION
+    //------------------------------------------------------------------------------
+
+    // Coefficients of the Chebyshev series interpolating 1/(2 Pi) Sin(2 Pi K x)
+    std::vector<double> coefficients;
+    double k = 0;
+
+    if (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY) {
+        coefficients = g_coefficientsSparse;
+        // k = K_SPARSE;
+        k = 1.0;  // do not divide by k as we already did it during precomputation
+    }
+    else {
+        coefficients = g_coefficientsUniform;
+        k            = K_UNIFORM;
+    }
+
+    double constantEvalMult = pre * (1.0 / (k * N));
+
+    cc->EvalMultInPlace(raised, constantEvalMult);
+
+    // no linear transformations are needed for Chebyshev series as the range has been normalized to [-1,1]
+  //  double coeffLowerBound = -1;
+  //  double coeffUpperBound = 1;
+
+    Ciphertext<DCRTPoly> ctxtDec;
+
+    bool isLTBootstrap = (precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1) &&
+                         (precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1);
+    if (slots == M / 4) {
+        //------------------------------------------------------------------------------
+        // FULLY PACKED CASE
+        //------------------------------------------------------------------------------
+
+#ifdef BOOTSTRAPTIMING
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running CoeffToSlot
+        //------------------------------------------------------------------------------
+
+        // need to call internal modular reduction so it also works for FLEXIBLEAUTO
+        algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
+
+        // only one linear transform is needed as the other one can be derived
+        auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
+                                         EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
+
+
+        return {ctxtEnc, ctxtEnc};
+
+        auto evalKeyMap = cc->GetEvalAutomorphismKeyMap(ctxtEnc->GetKeyTag());
+        auto conj       = Conjugate(ctxtEnc, evalKeyMap);
+        auto ctxtEncI   = cc->EvalSub(ctxtEnc, conj);
+        cc->EvalAddInPlace(ctxtEnc, conj);
+        algo->MultByMonomialInPlace(ctxtEncI, 3 * M / 4);
+
+        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+            while (ctxtEnc->GetNoiseScaleDeg() > 1) {
+                cc->ModReduceInPlace(ctxtEnc);
+                cc->ModReduceInPlace(ctxtEncI);
+            }
+        }
+        else {
+            if (ctxtEnc->GetNoiseScaleDeg() == 2) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+                algo->ModReduceInternalInPlace(ctxtEncI, BASE_NUM_LEVELS_TO_DROP);
+            }
+        }
+
+
+    }
+    return {
+        nullptr, nullptr };
+}
+
+Ciphertext<DCRTPoly> FHECKKSRNS::EvalBootstrapNoStC(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                               uint32_t precision) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ciphertext->GetCryptoParameters());
+
+    if (cryptoParams->GetKeySwitchTechnique() != HYBRID)
+        OPENFHE_THROW("CKKS Bootstrapping is only supported for the Hybrid key switching method.");
+#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTO || cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT)
+        OPENFHE_THROW("128-bit CKKS Bootstrapping is supported for FIXEDMANUAL and FIXEDAUTO methods only.");
+#endif
+    if (numIterations != 1 && numIterations != 2) {
+        OPENFHE_THROW("CKKS Iterative Bootstrapping is only supported for 1 or 2 iterations.");
+    }
+
+#ifdef BOOTSTRAPTIMING
+    TimeVar t;
+    double timeEncode(0.0);
+    double timeModReduce(0.0);
+    double timeDecode(0.0);
+#endif
+
+    auto cc        = ciphertext->GetCryptoContext();
+    uint32_t M     = cc->GetCyclotomicOrder();
+    uint32_t L0    = cryptoParams->GetElementParams()->GetParams().size();
+    auto initSizeQ = ciphertext->GetElements()[0].GetNumOfElements();
+
+    if (numIterations > 1) {
+        // Step 1: Get the input.
+        uint32_t powerOfTwoModulus = 1 << precision;
+
+        // Step 2: Scale up by powerOfTwoModulus, and extend the modulus to powerOfTwoModulus * q.
+        // Note that we extend the modulus implicitly without any code calls because the value always stays 0.
+        Ciphertext<DCRTPoly> ctScaledUp = ciphertext->Clone();
+        // We multiply by powerOfTwoModulus, and leave the last CRT value to be 0 (mod powerOfTwoModulus).
+        cc->GetScheme()->MultByIntegerInPlace(ctScaledUp, powerOfTwoModulus);
+        ctScaledUp->SetLevel(L0 - ctScaledUp->GetElements()[0].GetNumOfElements());
+
+        // Step 3: Bootstrap the initial ciphertext.
+        auto ctInitialBootstrap = cc->EvalBootstrap(ciphertext, numIterations - 1, precision);
+        cc->GetScheme()->ModReduceInternalInPlace(ctInitialBootstrap, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 4: Scale up by powerOfTwoModulus.
+        cc->GetScheme()->MultByIntegerInPlace(ctInitialBootstrap, powerOfTwoModulus);
+
+        // Step 5: Mod-down to powerOfTwoModulus * q
+        // We mod down, and leave the last CRT value to be 0 because it's divisible by powerOfTwoModulus.
+        auto ctBootstrappedScaledDown = ctInitialBootstrap->Clone();
+        auto bootstrappingSizeQ       = ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements();
+
+        // If we start with more towers, than we obtain from bootstrapping, return the original ciphertext.
+        if (bootstrappingSizeQ <= initSizeQ) {
+            return ciphertext->Clone();
+        }
+        for (auto& cv : ctBootstrappedScaledDown->GetElements()) {
+            cv.DropLastElements(bootstrappingSizeQ - initSizeQ);
+        }
+        ctBootstrappedScaledDown->SetLevel(L0 - ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements());
+
+        // Step 6 and 7: Calculate the bootstrapping error by subtracting the original ciphertext from the bootstrapped ciphertext. Mod down to q is done implicitly.
+        auto ctBootstrappingError = cc->EvalSub(ctBootstrappedScaledDown, ctScaledUp);
+
+        // Step 8: Bootstrap the error.
+        auto ctBootstrappedError = cc->EvalBootstrap(ctBootstrappingError, 1, 0);
+        cc->GetScheme()->ModReduceInternalInPlace(ctBootstrappedError, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 9: Subtract the bootstrapped error from the initial bootstrap to get even lower error.
+        auto finalCiphertext = cc->EvalSub(ctInitialBootstrap, ctBootstrappedError);
+
+        // Step 10: Scale back down by powerOfTwoModulus to get the original message.
+        cc->EvalMultInPlace(finalCiphertext, static_cast<double>(1) / powerOfTwoModulus);
+        return finalCiphertext;
+    }
+
+    uint32_t slots = ciphertext->GetSlots();
+
+    auto pair = m_bootPrecomMap.find(slots);
+    if (pair == m_bootPrecomMap.end()) {
+        std::string errorMsg(std::string("Precomputations for ") + std::to_string(slots) +
+                             std::string(" slots were not generated") +
+                             std::string(" Need to call EvalBootstrapSetup and then EvalBootstrapKeyGen to proceed"));
+        OPENFHE_THROW(errorMsg);
+    }
+    const std::shared_ptr<CKKSBootstrapPrecom> precom = pair->second;
+    size_t N                                          = cc->GetRingDimension();
+
+    auto elementParamsRaised = *(cryptoParams->GetElementParams());
+
+    // For FLEXIBLEAUTOEXT we raised ciphertext does not include extra modulus
+    // as it is multiplied by auxiliary plaintext
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT) {
+        elementParamsRaised.PopLastParam();
+    }
+
+    auto paramsQ = elementParamsRaised.GetParams();
+    usint sizeQ  = paramsQ.size();
+
+    std::vector<NativeInteger> moduli(sizeQ);
+    std::vector<NativeInteger> roots(sizeQ);
+    for (size_t i = 0; i < sizeQ; i++) {
+        moduli[i] = paramsQ[i]->GetModulus();
+        roots[i]  = paramsQ[i]->GetRootOfUnity();
+    }
+    auto elementParamsRaisedPtr = std::make_shared<ILDCRTParams<DCRTPoly::Integer>>(M, moduli, roots);
 
-        uint32_t depthBT = approxModDepth + precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] +
-                           precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET];
+    NativeInteger q = elementParamsRaisedPtr->GetParams()[0]->GetModulus().ConvertToInt();
+    double qDouble  = q.ConvertToDouble();
 
-        // compute # of levels to remain when encoding the coefficients
-        // for FLEXIBLEAUTOEXT we do not need extra modulus in auxiliary plaintexts
-        auto st     = cryptoParams->GetScalingTechnique();
-        uint32_t L0 = cryptoParams->GetElementParams()->GetParams().size() - (st == FLEXIBLEAUTOEXT);
+    const auto p = cryptoParams->GetPlaintextModulus();
+    double powP  = pow(2, p);
 
-        uint32_t lEnc = L0 - compositeDegree * (precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] + 1);
-        uint32_t lDec = L0 - compositeDegree * depthBT;
+    int32_t deg = std::round(std::log2(qDouble / powP));
+#if NATIVEINT != 128
+    if (deg > static_cast<int32_t>(m_correctionFactor)) {
+        OPENFHE_THROW("Degree [" + std::to_string(deg) + "] must be less than or equal to the correction factor [" +
+                      std::to_string(m_correctionFactor) + "].");
+    }
+#endif
+    uint32_t correction = m_correctionFactor - deg;
+    double post         = std::pow(2, static_cast<double>(deg));
 
-        bool isLTBootstrap = (precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1) &&
-                             (precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1);
+    double pre      = 1. / post;
+    uint64_t scalar = std::llround(post);
 
-        if (isLTBootstrap) {
-            // allocate all vectors
-            std::vector<std::vector<std::complex<double>>> U0(slots, std::vector<std::complex<double>>(slots));
-            std::vector<std::vector<std::complex<double>>> U1(slots, std::vector<std::complex<double>>(slots));
-            std::vector<std::vector<std::complex<double>>> U0hatT(slots, std::vector<std::complex<double>>(slots));
-            std::vector<std::vector<std::complex<double>>> U1hatT(slots, std::vector<std::complex<double>>(slots));
+    //------------------------------------------------------------------------------
+    // RAISING THE MODULUS
+    //------------------------------------------------------------------------------
 
-            for (uint32_t i = 0; i < slots; i++) {
-                for (uint32_t j = 0; j < slots; j++) {
-                    U0[i][j]     = ksiPows[(j * rotGroup[i]) & mmask];
-                    U0hatT[j][i] = std::conj(U0[i][j]);
-                    U1[i][j]     = std::complex<double>(0, 1) * U0[i][j];
-                    U1hatT[j][i] = std::conj(U1[i][j]);
-                }
+    // In FLEXIBLEAUTO, raising the ciphertext to a larger number
+    // of towers is a bit more complex, because we need to adjust
+    // it's scaling factor to the one that corresponds to the level
+    // it's being raised to.
+    // Increasing the modulus
+
+    Ciphertext<DCRTPoly> raised = ciphertext->Clone();
+    auto algo                   = cc->GetScheme();
+    algo->ModReduceInternalInPlace(raised, raised->GetNoiseScaleDeg() - 1);
+
+    AdjustCiphertext(raised, correction);
+    auto ctxtDCRT = raised->GetElements();
+
+    // We only use the level 0 ciphertext here. All other towers are automatically ignored to make
+    // CKKS bootstrapping faster.
+    for (size_t i = 0; i < ctxtDCRT.size(); i++) {
+        DCRTPoly temp(elementParamsRaisedPtr, COEFFICIENT);
+        ctxtDCRT[i].SetFormat(COEFFICIENT);
+        temp = ctxtDCRT[i].GetElementAtIndex(0);
+        temp.SetFormat(EVALUATION);
+        ctxtDCRT[i] = temp;
+    }
+
+    raised->SetElements(ctxtDCRT);
+    raised->SetLevel(L0 - ctxtDCRT[0].GetNumOfElements());
+
+#ifdef BOOTSTRAPTIMING
+    std::cerr << "\nNumber of levels at the beginning of bootstrapping: "
+              << raised->GetElements()[0].GetNumOfElements() - 1 << std::endl;
+#endif
+
+    //------------------------------------------------------------------------------
+    // SETTING PARAMETERS FOR APPROXIMATE MODULAR REDUCTION
+    //------------------------------------------------------------------------------
+
+    // Coefficients of the Chebyshev series interpolating 1/(2 Pi) Sin(2 Pi K x)
+    std::vector<double> coefficients;
+    double k = 0;
+
+    if (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY) {
+        coefficients = g_coefficientsSparse;
+        // k = K_SPARSE;
+        k = 1.0;  // do not divide by k as we already did it during precomputation
+    }
+    else {
+        coefficients = g_coefficientsUniform;
+        k            = K_UNIFORM;
+    }
+
+    double constantEvalMult = pre * (1.0 / (k * N));
+
+    cc->EvalMultInPlace(raised, constantEvalMult);
+
+    // no linear transformations are needed for Chebyshev series as the range has been normalized to [-1,1]
+    double coeffLowerBound = -1;
+    double coeffUpperBound = 1;
+
+    Ciphertext<DCRTPoly> ctxtDec;
+
+    bool isLTBootstrap = (precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1) &&
+                         (precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1);
+    if (slots == M / 4) {
+        //------------------------------------------------------------------------------
+        // FULLY PACKED CASE
+        //------------------------------------------------------------------------------
+
+#ifdef BOOTSTRAPTIMING
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running CoeffToSlot
+        //------------------------------------------------------------------------------
+
+        // need to call internal modular reduction so it also works for FLEXIBLEAUTO
+        algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
+
+        // only one linear transform is needed as the other one can be derived
+        auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
+                                         EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
+
+        auto evalKeyMap = cc->GetEvalAutomorphismKeyMap(ctxtEnc->GetKeyTag());
+        auto conj       = Conjugate(ctxtEnc, evalKeyMap);
+        auto ctxtEncI   = cc->EvalSub(ctxtEnc, conj);
+        cc->EvalAddInPlace(ctxtEnc, conj);
+        algo->MultByMonomialInPlace(ctxtEncI, 3 * M / 4);
+
+        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+            while (ctxtEnc->GetNoiseScaleDeg() > 1) {
+                cc->ModReduceInPlace(ctxtEnc);
+                cc->ModReduceInPlace(ctxtEncI);
+            }
+        }
+        else {
+            if (ctxtEnc->GetNoiseScaleDeg() == 2) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+                algo->ModReduceInternalInPlace(ctxtEncI, BASE_NUM_LEVELS_TO_DROP);
             }
+        }
 
-            if (!isSparse) {
-                precom->m_U0hatTPre = EvalLinearTransformPrecompute(cc, U0hatT, scaleEnc, lEnc);
-                precom->m_U0Pre     = EvalLinearTransformPrecompute(cc, U0, scaleDec, lDec);
+        //------------------------------------------------------------------------------
+        // Running Approximate Mod Reduction
+        //------------------------------------------------------------------------------
+
+        // Evaluate Chebyshev series for the sine wave
+        ctxtEnc  = cc->EvalChebyshevSeries(ctxtEnc, coefficients, coeffLowerBound, coeffUpperBound);
+        ctxtEncI = cc->EvalChebyshevSeries(ctxtEncI, coefficients, coeffLowerBound, coeffUpperBound);
+
+        // Double-angle iterations
+        if ((cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY) ||
+            (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY)) {
+            if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+                algo->ModReduceInternalInPlace(ctxtEncI, BASE_NUM_LEVELS_TO_DROP);
             }
-            else {
-                precom->m_U0hatTPre = EvalLinearTransformPrecompute(cc, U0hatT, U1hatT, 0, scaleEnc, lEnc);
-                precom->m_U0Pre     = EvalLinearTransformPrecompute(cc, U0, U1, 1, scaleDec, lDec);
+            uint32_t numIter;
+            if (cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY)
+                numIter = R_UNIFORM;
+            else
+                numIter = R_SPARSE;
+            ApplyDoubleAngleIterations(ctxtEnc, numIter);
+            ApplyDoubleAngleIterations(ctxtEncI, numIter);
+        }
+
+        algo->MultByMonomialInPlace(ctxtEncI, M / 4);
+        cc->EvalAddInPlace(ctxtEnc, ctxtEncI);
+
+        // scale the message back up after Chebyshev interpolation
+        algo->MultByIntegerInPlace(ctxtEnc, scalar);
+
+#ifdef BOOTSTRAPTIMING
+        timeModReduce = TOC(t);
+
+        std::cerr << "Approximate modular reduction time: " << timeModReduce / 1000.0 << " s" << std::endl;
+
+        // Running SlotToCoeff
+
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running SlotToCoeff
+        //------------------------------------------------------------------------------
+
+        // In the case of FLEXIBLEAUTO, we need one extra tower
+        // TODO: See if we can remove the extra level in FLEXIBLEAUTO
+        if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+            algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+        }
+
+        return ctxtEnc;
+        // Only one linear transform is needed
+        ctxtDec = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0Pre, ctxtEnc) :
+                                    EvalSlotsToCoeffs(precom->m_U0PreFFT, ctxtEnc);
+    }
+    else {
+        //------------------------------------------------------------------------------
+        // SPARSELY PACKED CASE
+        //------------------------------------------------------------------------------
+
+        //------------------------------------------------------------------------------
+        // Running PartialSum
+        //------------------------------------------------------------------------------
+
+        for (uint32_t j = 1; j < N / (2 * slots); j <<= 1) {
+            auto temp = cc->EvalRotate(raised, j * slots);
+            cc->EvalAddInPlace(raised, temp);
+        }
+
+#ifdef BOOTSTRAPTIMING
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running CoeffsToSlots
+        //------------------------------------------------------------------------------
+
+        algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
+
+
+        auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
+                                         EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
+
+        auto evalKeyMap = cc->GetEvalAutomorphismKeyMap(ctxtEnc->GetKeyTag());
+        auto conj       = Conjugate(ctxtEnc, evalKeyMap);
+        cc->EvalAddInPlace(ctxtEnc, conj);
+
+        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+            while (ctxtEnc->GetNoiseScaleDeg() > 1) {
+                cc->ModReduceInPlace(ctxtEnc);
             }
         }
         else {
-            precom->m_U0hatTPreFFT = EvalCoeffsToSlotsPrecompute(cc, ksiPows, rotGroup, false, scaleEnc, lEnc);
-            precom->m_U0PreFFT     = EvalSlotsToCoeffsPrecompute(cc, ksiPows, rotGroup, false, scaleDec, lDec);
+            if (ctxtEnc->GetNoiseScaleDeg() == 2) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+            }
+        }
+
+#ifdef BOOTSTRAPTIMING
+        timeEncode = TOC(t);
+
+        std::cerr << "\nEncoding time: " << timeEncode / 1000.0 << " s" << std::endl;
+
+        // Running Approximate Mod Reduction
+
+        TIC(t);
+#endif
+        //------------------------------------------------------------------------------
+        // Running Approximate Mod Reduction
+        //------------------------------------------------------------------------------
+
+        // Evaluate Chebyshev series for the sine wave
+        ctxtEnc = cc->EvalChebyshevSeries(ctxtEnc, coefficients, coeffLowerBound, coeffUpperBound);
+
+        // Double-angle iterations
+        if ((cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY) ||
+            (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY)) {
+            if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+            }
+            uint32_t numIter;
+            if (cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY)
+                numIter = R_UNIFORM;
+            else
+                numIter = R_SPARSE;
+            ApplyDoubleAngleIterations(ctxtEnc, numIter);
+        }
+
+        // scale the message back up after Chebyshev interpolation
+        algo->MultByIntegerInPlace(ctxtEnc, scalar);
+
+#ifdef BOOTSTRAPTIMING
+        timeModReduce = TOC(t);
+
+        std::cerr << "Approximate modular reduction time: " << timeModReduce / 1000.0 << " s" << std::endl;
+
+        // Running SlotToCoeff
+
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running SlotsToCoeffs
+        //------------------------------------------------------------------------------
+
+        // In the case of FLEXIBLEAUTO, we need one extra tower
+        // TODO: See if we can remove the extra level in FLEXIBLEAUTO
+        if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+            algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
         }
+
+        return ctxtEnc;
+
+        // linear transform for decoding
+        ctxtDec = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0Pre, ctxtEnc) :
+                                    EvalSlotsToCoeffs(precom->m_U0PreFFT, ctxtEnc);
+
+        cc->EvalAddInPlace(ctxtDec, cc->EvalRotate(ctxtDec, slots));
+    }
+
+#if NATIVEINT != 128
+    // 64-bit only: scale back the message to its original scale.
+    uint64_t corFactor = (uint64_t)1 << std::llround(correction);
+    algo->MultByIntegerInPlace(ctxtDec, corFactor);
+#endif
+
+#ifdef BOOTSTRAPTIMING
+    timeDecode = TOC(t);
+
+    std::cout << "Decoding time: " << timeDecode / 1000.0 << " s" << std::endl;
+#endif
+
+    auto bootstrappingNumTowers = ctxtDec->GetElements()[0].GetNumOfElements();
+
+    // If we start with more towers, than we obtain from bootstrapping, return the original ciphertext.
+    if (bootstrappingNumTowers <= initSizeQ) {
+        return ciphertext->Clone();
     }
+
+    return ctxtDec;
 }
 
 std::shared_ptr<std::map<uint32_t, EvalKey<DCRTPoly>>> FHECKKSRNS::EvalBootstrapKeyGen(
@@ -988,7 +2043,7 @@ std::vector<uint32_t> FHECKKSRNS::FindSlotsToCoeffsRotationIndices(uint32_t slot
 
 std::vector<ReadOnlyPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
     const CryptoContextImpl<DCRTPoly>& cc, const std::vector<std::vector<std::complex<double>>>& A, double scale,
-    uint32_t L) const {
+    uint32_t L, bool extended) const {
     uint32_t slots = A.size();
     if (slots != A[0].size())
         OPENFHE_THROW("The matrix passed to EvalLTPrecompute is not square");
@@ -1004,7 +2059,7 @@ std::vector<ReadOnlyPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
     auto paramsQ   = elementParams.GetParams();
     uint32_t sizeQ = paramsQ.size();
     auto paramsP   = cryptoParams->GetParamsP()->GetParams();
-    uint32_t sizeP = paramsP.size();
+    uint32_t sizeP = extended ? paramsP.size() : 0;
     std::vector<NativeInteger> moduli(sizeQ + sizeP);
     std::vector<NativeInteger> roots(sizeQ + sizeP);
     for (uint32_t i = 0; i < sizeQ; ++i) {
@@ -1038,6 +2093,11 @@ std::vector<ReadOnlyPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
 
                 result[bStep * j + i] =
                     MakeAuxPlaintext(cc, elementParamsPtr, Rotate(diag, offset), 1, towersToDrop, diag.size());
+
+                if(!extended) {
+                                      result[bStep * j + i] =
+                                            cc.MakeCKKSPackedPlaintext(Rotate(diag, offset), 1, towersToDrop, nullptr, diag.size());
+                                    }
             }
         }
     }
@@ -1046,7 +2106,7 @@ std::vector<ReadOnlyPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
 
 std::vector<ReadOnlyPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
     const CryptoContextImpl<DCRTPoly>& cc, const std::vector<std::vector<std::complex<double>>>& A,
-    const std::vector<std::vector<std::complex<double>>>& B, uint32_t orientation, double scale, uint32_t L) const {
+    const std::vector<std::vector<std::complex<double>>>& B, uint32_t orientation, double scale, uint32_t L, bool extended) const {
     // make sure the plaintext is created only with the necessary amount of moduli
     const auto cryptoParams  = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(cc.GetCryptoParameters());
     uint32_t compositeDegree = cryptoParams->GetCompositeDegree();
@@ -1059,7 +2119,7 @@ std::vector<ReadOnlyPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
     auto paramsQ   = elementParams.GetParams();
     uint32_t sizeQ = paramsQ.size();
     auto paramsP   = cryptoParams->GetParamsP()->GetParams();
-    uint32_t sizeP = paramsP.size();
+    uint32_t sizeP = extended ? paramsP.size() : 0;
     std::vector<NativeInteger> moduli(sizeQ + sizeP);
     std::vector<NativeInteger> roots(sizeQ + sizeP);
     for (uint32_t i = 0; i < sizeQ; ++i) {
@@ -1097,6 +2157,10 @@ std::vector<ReadOnlyPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
 
                     result[bStep * j + i] =
                         MakeAuxPlaintext(cc, elementParamsPtr, Rotate(vecA, offset), 1, towersToDrop, vecA.size());
+                    if(!extended) {
+                                                result[bStep * j + i] =
+                                                    cc.MakeCKKSPackedPlaintext(Rotate(vecA, offset), 1, towersToDrop, elementParamsPtr, vecA.size());
+                                            }
                 }
             }
         }
@@ -1125,6 +2189,13 @@ std::vector<ReadOnlyPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
 
                     result[bStep * j + i] =
                         MakeAuxPlaintext(cc, elementParamsPtr, Rotate(vec, offset), 1, towersToDrop, vec.size());
+
+                    MakeAuxPlaintext(cc, elementParamsPtr, Rotate(vec, offset), 1, towersToDrop, vec.size());
+
+                                        if(!extended) {
+                                                result[bStep * j + i] =
+                                                    cc.MakeCKKSPackedPlaintext(Rotate(vec, offset), 1, towersToDrop, nullptr, vec.size());
+                                            }
                 }
             }
         }
-- 
2.43.0

