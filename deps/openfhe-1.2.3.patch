From 1e6835770825d508efb63758648711c1b477a951 Mon Sep 17 00:00:00 2001
From: FIDESlib <FIDESlib>
Date: Thu, 18 Sep 2025 11:42:55 +0200
Subject: [PATCH] FIDESlib Patch.

---
 CMakeLists.txt                                |   15 +-
 src/binfhe/include/binfhe-base-scheme.h       |    2 +-
 src/binfhe/include/lwe-ciphertext.h           |    2 +-
 src/binfhe/include/lwe-cryptoparameters.h     |    2 +-
 src/binfhe/include/lwe-keyswitchkey.h         |    2 +-
 src/binfhe/include/lwe-privatekey.h           |    2 +-
 src/binfhe/include/lwe-publickey.h            |    2 +-
 src/binfhe/include/rgsw-acc-cggi.h            |    2 +-
 src/binfhe/include/rgsw-acc-dm.h              |    2 +-
 src/binfhe/include/rgsw-acckey.h              |    2 +-
 src/binfhe/include/rlwe-ciphertext.h          |    2 +-
 src/core/include/lattice/dgsampling.h         |    2 +-
 src/core/include/lattice/field2n.h            |    2 +-
 .../include/lattice/hal/dcrtpoly-interface.h  |    2 +-
 .../lattice/hal/default/dcrtpoly-impl.h       |   82 +-
 .../include/lattice/hal/default/dcrtpoly.h    |    2 +-
 .../lattice/hal/default/ildcrtparams.h        |    2 +-
 .../include/lattice/hal/default/ilparams.h    |    2 +-
 .../include/lattice/hal/default/poly-impl.h   |    1 +
 src/core/include/lattice/hal/default/poly.h   |    2 +-
 src/core/include/lattice/hal/elemparams.h     |    2 +-
 src/core/include/lattice/hal/poly-interface.h |    2 +-
 src/core/include/lattice/trapdoorparameters.h |    6 +-
 .../include/math/binaryuniformgenerator.h     |    2 +-
 src/core/include/math/dftransform.h           |    2 +-
 .../include/math/discretegaussiangenerator.h  |    2 +-
 .../math/discretegaussiangeneratorgeneric.h   |    8 +-
 .../include/math/discreteuniformgenerator.h   |    2 +-
 .../include/math/hal/bigintdyn/mubintvecdyn.h |    2 +-
 .../include/math/hal/bigintdyn/ubintdyn.h     |    4 +-
 .../include/math/hal/bigintfxd/ubintfxd.h     |    4 +-
 .../include/math/hal/bigintntl/mubintvecntl.h |    2 +-
 .../include/math/hal/bigintntl/ubintntl.h     |    2 +-
 .../include/math/hal/intnat/mubintvecnat.h    |    2 +-
 src/core/include/math/hal/intnat/ubintnat.h   |    4 +-
 src/core/include/utils/parallel.h             |    2 +-
 src/core/include/utils/sertype.h              |    3 +
 src/core/lib/math/chebyshev.cpp               |    2 +
 src/core/lib/math/distributiongenerator.cpp   |    1 +
 src/core/lib/math/hal/intnat/mubintvecnat.cpp |    2 +
 src/core/lib/math/nbtheory2.cpp               |    4 +
 src/pke/include/ciphertext.h                  |    2 +-
 src/pke/include/cryptocontext.h               |   10 +-
 src/pke/include/cryptocontextfactory.h        |    2 +-
 src/pke/include/cryptoobject.h                |    2 +-
 src/pke/include/encoding/ckkspackedencoding.h |    2 +-
 src/pke/include/encoding/encodingparams.h     |    2 +-
 src/pke/include/encoding/packedencoding.h     |    2 +-
 src/pke/include/encoding/plaintext.h          |    4 +-
 src/pke/include/key/evalkeyrelin.h            |    2 +-
 src/pke/include/key/privatekey.h              |    2 +-
 src/pke/include/key/publickey.h               |    2 +-
 .../include/scheme/bfvrns/bfvrns-leveledshe.h |    2 +-
 .../bgvrns/bgvrns-parametergeneration.h       |    2 +-
 src/pke/include/scheme/ckksrns/ckksrns-fhe.h  |   21 +-
 .../scheme/ckksrns/ckksrns-schemeswitching.h  |    2 +-
 .../include/scheme/gen-cryptocontext-params.h |    2 +-
 src/pke/include/schemebase/base-advancedshe.h |    2 +-
 .../schemebase/base-cryptoparameters.h        |    4 +-
 src/pke/include/schemebase/base-fhe.h         |    3 +-
 src/pke/include/schemebase/base-leveledshe.h  |    2 +-
 src/pke/include/schemebase/base-scheme.h      |   17 +-
 .../schemebase/rlwe-cryptoparameters.h        |    2 +-
 .../include/schemerns/rns-cryptoparameters.h  |    4 +-
 src/pke/include/schemerns/rns-leveledshe.h    |    2 +-
 .../schemerns/rns-parametergeneration.h       |    2 +-
 src/pke/lib/cryptocontext.cpp                 |   26 +-
 src/pke/lib/keyswitch/keyswitch-hybrid.cpp    |    3 +-
 .../scheme/ckksrns/ckksrns-advancedshe.cpp    |   10 +-
 src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp    | 1119 ++++++++++++++++-
 .../lib/scheme/ckksrns/ckksrns-leveledshe.cpp |    1 +
 src/pke/lib/scheme/ckksrns/ckksrns-utils.cpp  |   16 +-
 src/pke/lib/schemebase/base-leveledshe.cpp    |    5 +-
 src/pke/unittest/utils/BaseTestCase.h         |    2 +-
 third-party/google-benchmark                  |    2 +-
 third-party/google-test                       |    2 +-
 third-party/gperftools                        |    2 +-
 77 files changed, 1367 insertions(+), 112 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 37e5a4ab..379f4e77 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -23,6 +23,9 @@ endif()
 ##endif()
 ### TODO: for now, we use CLang for Mac
 
+set (CMAKE_C_COMPILER "/usr/bin/clang")
+set (CMAKE_CXX_COMPILER "/usr/bin/clang++")
+
 project (OpenFHE C CXX)
 
 set(OPENFHE_VERSION_MAJOR 1)
@@ -60,14 +63,22 @@ if ( EMSCRIPTEN )
     set(WITH_OPENMP OFF)
     message( "OpenMP is not supported by Emscripten" )
 else()
-    option( BUILD_SHARED "Set to ON to build shared versions of the library"         ON  )
-    option( BUILD_STATIC "Set to ON to build static versions of the library"         OFF )
+    option( BUILD_SHARED "Set to ON to build shared versions of the library"         OFF  )
+    option( BUILD_STATIC "Set to ON to build static versions of the library"         ON )
     option( BUILD_UNITTESTS "Set to ON to build unit tests for the library"          ON  )
     option( BUILD_EXAMPLES "Set to ON to build examples for the library"             ON  )
     option( BUILD_BENCHMARKS "Set to ON to build benchmarks for the library"         ON  )
     option( WITH_OPENMP "Use OpenMP to enable <omp.h>"                               ON  )
 endif()
 
+set( BUILD_SHARED ON )
+set( BUILD_STATIC ON )
+set ( BUILD_UNITTESTS OFF)
+set ( BUILD_EXAMPLES OFF)
+set ( BUILD_BENCHMARKS OFF)
+set ( WITH_OPENMP ON)
+set ( WITH_BE2 ON)
+
 option( BUILD_EXTRAS "Set to ON to build extras for the library"                     OFF )
 option( GIT_SUBMOD_AUTO "Submodules auto-update"                                     ON  )
 option( WITH_BE2 "Include MATHBACKEND 2 in build by setting WITH_BE2 to ON"          OFF )
diff --git a/src/binfhe/include/binfhe-base-scheme.h b/src/binfhe/include/binfhe-base-scheme.h
index df3ac368..eb8e9beb 100644
--- a/src/binfhe/include/binfhe-base-scheme.h
+++ b/src/binfhe/include/binfhe-base-scheme.h
@@ -231,7 +231,7 @@ private:
     LWECiphertext BootstrapFunc(const std::shared_ptr<BinFHECryptoParams>& params, const RingGSWBTKey& EK,
                                 ConstLWECiphertext& ct, const Func f, const NativeInteger& fmod) const;
 
-protected:
+public:
     std::shared_ptr<LWEEncryptionScheme> LWEscheme{std::make_shared<LWEEncryptionScheme>()};
     std::shared_ptr<RingGSWAccumulator> ACCscheme{nullptr};
 
diff --git a/src/binfhe/include/lwe-ciphertext.h b/src/binfhe/include/lwe-ciphertext.h
index 5540995a..02462ffa 100644
--- a/src/binfhe/include/lwe-ciphertext.h
+++ b/src/binfhe/include/lwe-ciphertext.h
@@ -155,7 +155,7 @@ public:
         return 1;
     }
 
-private:
+public:
     NativeVector m_a{};
     NativeInteger m_b{};
     NativeInteger m_p = 4;  // pt modulus
diff --git a/src/binfhe/include/lwe-cryptoparameters.h b/src/binfhe/include/lwe-cryptoparameters.h
index f5768f23..142978af 100644
--- a/src/binfhe/include/lwe-cryptoparameters.h
+++ b/src/binfhe/include/lwe-cryptoparameters.h
@@ -218,7 +218,7 @@ public:
         return 1;
     }
 
-private:
+public:
     // modulus for the additive LWE scheme
     NativeInteger m_q{};
     // modulus for the RingGSW/RingLWE scheme
diff --git a/src/binfhe/include/lwe-keyswitchkey.h b/src/binfhe/include/lwe-keyswitchkey.h
index b3692ff8..8d553db7 100644
--- a/src/binfhe/include/lwe-keyswitchkey.h
+++ b/src/binfhe/include/lwe-keyswitchkey.h
@@ -123,7 +123,7 @@ public:
         return 1;
     }
 
-private:
+public:
     std::vector<std::vector<std::vector<NativeVector>>> m_keyA;
     std::vector<std::vector<std::vector<NativeInteger>>> m_keyB;
 };
diff --git a/src/binfhe/include/lwe-privatekey.h b/src/binfhe/include/lwe-privatekey.h
index cc875c04..d5c5b24e 100644
--- a/src/binfhe/include/lwe-privatekey.h
+++ b/src/binfhe/include/lwe-privatekey.h
@@ -111,7 +111,7 @@ public:
         return 1;
     }
 
-private:
+public:
     NativeVector m_s{};
 };
 
diff --git a/src/binfhe/include/lwe-publickey.h b/src/binfhe/include/lwe-publickey.h
index ce82b425..4d1c29ee 100644
--- a/src/binfhe/include/lwe-publickey.h
+++ b/src/binfhe/include/lwe-publickey.h
@@ -125,7 +125,7 @@ public:
         return 1;
     }
 
-private:
+public:
     std::vector<NativeVector> m_A;
     NativeVector m_v;
 };
diff --git a/src/binfhe/include/rgsw-acc-cggi.h b/src/binfhe/include/rgsw-acc-cggi.h
index c2b0f6bb..b77d9f21 100644
--- a/src/binfhe/include/rgsw-acc-cggi.h
+++ b/src/binfhe/include/rgsw-acc-cggi.h
@@ -68,7 +68,7 @@ public:
     void EvalAcc(const std::shared_ptr<RingGSWCryptoParams>& params, ConstRingGSWACCKey& ek, RLWECiphertext& acc,
                  const NativeVector& a) const override;
 
-private:
+public:
     /**
    * Key generation for internal Ring GSW as described in https://eprint.iacr.org/2020/086
    *
diff --git a/src/binfhe/include/rgsw-acc-dm.h b/src/binfhe/include/rgsw-acc-dm.h
index b39690c9..2f52981e 100644
--- a/src/binfhe/include/rgsw-acc-dm.h
+++ b/src/binfhe/include/rgsw-acc-dm.h
@@ -68,7 +68,7 @@ public:
     void EvalAcc(const std::shared_ptr<RingGSWCryptoParams>& params, ConstRingGSWACCKey& ek, RLWECiphertext& acc,
                  const NativeVector& a) const override;
 
-private:
+public:
     /**
    * DM Key generation for internal Ring GSW as described in https://eprint.iacr.org/2014/816
    *
diff --git a/src/binfhe/include/rgsw-acckey.h b/src/binfhe/include/rgsw-acckey.h
index a999608d..01d82669 100644
--- a/src/binfhe/include/rgsw-acckey.h
+++ b/src/binfhe/include/rgsw-acckey.h
@@ -154,7 +154,7 @@ public:
         return 1;
     }
 
-private:
+public:
     using dim3_t = std::vector<RingGSWEvalKey>;
     using dim2_t = std::vector<dim3_t>;
     using dim1_t = std::vector<dim2_t>;
diff --git a/src/binfhe/include/rlwe-ciphertext.h b/src/binfhe/include/rlwe-ciphertext.h
index c3946cdd..941aa725 100644
--- a/src/binfhe/include/rlwe-ciphertext.h
+++ b/src/binfhe/include/rlwe-ciphertext.h
@@ -123,7 +123,7 @@ public:
         return 1;
     }
 
-private:
+public:
     std::vector<NativePoly> m_elements;
 };
 
diff --git a/src/core/include/lattice/dgsampling.h b/src/core/include/lattice/dgsampling.h
index 07c6a7f3..3608c1d0 100644
--- a/src/core/include/lattice/dgsampling.h
+++ b/src/core/include/lattice/dgsampling.h
@@ -154,7 +154,7 @@ public:
     static std::shared_ptr<Matrix<int64_t>> ZSampleF(const Field2n& f, const Field2n& c,
                                                      const typename Element::DggType& dgg, size_t n);
 
-private:
+public:
     // subroutine used by GaussSampGq
     // Discrete sampling variant
     // As described in Figure 2 of https://eprint.iacr.org/2017/308.pdf
diff --git a/src/core/include/lattice/field2n.h b/src/core/include/lattice/field2n.h
index 8d567616..9cd1efaf 100644
--- a/src/core/include/lattice/field2n.h
+++ b/src/core/include/lattice/field2n.h
@@ -55,7 +55,7 @@ namespace lbcrypto {
  * @brief A class to represent field elements with power-of-2 dimension.
  */
 class Field2n : public std::vector<std::complex<double>>, public Serializable {
-private:
+public:
     // Format of the field element
     Format format{Format::COEFFICIENT};
 
diff --git a/src/core/include/lattice/hal/dcrtpoly-interface.h b/src/core/include/lattice/hal/dcrtpoly-interface.h
index ba3343b5..9fe4b230 100644
--- a/src/core/include/lattice/hal/dcrtpoly-interface.h
+++ b/src/core/include/lattice/hal/dcrtpoly-interface.h
@@ -1430,7 +1430,7 @@ public:
         return this->GetDerived().GetElementName();
     }
 
-protected:
+public:
     /**
    * @brief ostream operator
    * @param os the input preceding output stream
diff --git a/src/core/include/lattice/hal/default/dcrtpoly-impl.h b/src/core/include/lattice/hal/default/dcrtpoly-impl.h
index 3d00b236..b78b038a 100644
--- a/src/core/include/lattice/hal/default/dcrtpoly-impl.h
+++ b/src/core/include/lattice/hal/default/dcrtpoly-impl.h
@@ -714,11 +714,12 @@ void DCRTPolyImpl<VecType>::DropLastElements(size_t i) {
 template <typename VecType>
 void DCRTPolyImpl<VecType>::DropLastElementAndScale(const std::vector<NativeInteger>& QlQlInvModqlDivqlModq,
                                                     const std::vector<NativeInteger>& qlInvModq) {
+
     auto lastPoly(m_vectors.back());
     lastPoly.SetFormat(Format::COEFFICIENT);
     this->DropLastElement();
     size_t size{m_vectors.size()};
-
+/*
 #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
     for (size_t i = 0; i < size; ++i) {
         auto tmp = lastPoly;
@@ -731,6 +732,24 @@ void DCRTPolyImpl<VecType>::DropLastElementAndScale(const std::vector<NativeInte
         if (m_format == Format::COEFFICIENT)
             m_vectors[i].SwitchFormat();
     }
+*/
+
+
+#pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+    for (size_t i = 0; i < size; ++i) {
+        auto tmp = lastPoly;
+        tmp.SwitchModulus(m_vectors[i].GetModulus(), m_vectors[i].GetRootOfUnity(), 0, 0);
+
+        tmp *= QlQlInvModqlDivqlModq[i];
+        if (tmp.m_format == Format::COEFFICIENT) {
+            tmp.SwitchFormat();
+        }
+        m_vectors[i] *= qlInvModq[i];
+        m_vectors[i] += tmp;
+        //m_vectors[i] = tmp; // first test
+    }
+
+
 }
 
 /**
@@ -917,6 +936,7 @@ DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::ApproxSwitchCRTBasis(
 #if defined(HAVE_INT128) && NATIVEINT == 64
     uint32_t ringDim = m_params->GetRingDimension();
     std::vector<DoubleNativeInt> sum(sizeP);
+    //std::cout << "DIGIT[0][0] SCALE ";
     #pragma omp parallel for firstprivate(sum) num_threads(OpenFHEParallelControls.GetThreadLimit(8))
     for (uint32_t ri = 0; ri < ringDim; ++ri) {
         std::fill(sum.begin(), sum.end(), 0);
@@ -926,8 +946,20 @@ DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::ApproxSwitchCRTBasis(
             const auto& QHatModpi = QHatModp[i];
             const auto xQHatInvModqi =
                 xi.ModMulFastConst(QHatInvModq[i], qi, QHatInvModqPrecon[i]).template ConvertToInt<uint64_t>();
-            for (uint32_t j = 0; j < sizeP; ++j)
+
+            /*
+            if(ri < 8) {
+                //auto& i = partsCtCompl[part].m_vectors[0];
+                //std::cout << i.m_params.get()->m_ciphertextModulus << " ";
+                {
+                   std::cout << xQHatInvModqi << " \n"[i == sizeQ - 1];
+                }
+            }
+             */
+
+            for (uint32_t j = 0; j < sizeP; ++j) {
                 sum[j] += Mul128(xQHatInvModqi, QHatModpi[j].ConvertToInt<uint64_t>());
+            }
         }
         for (uint32_t j = 0; j < sizeP; ++j) {
             const auto& pj       = ans.m_vectors[j].GetModulus();
@@ -999,10 +1031,45 @@ DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::ApproxModDown(
             partP.m_vectors[j] *= tInvModp[j];
     }
     partP.OverrideFormat(Format::COEFFICIENT);
+/*
+    std::cout << "INTT Special: \n";
+    for(auto & i_ : partP.m_vectors){
+        std::cout << i_.m_params->m_ciphertextModulus << " " << i_.m_params->m_rootOfUnity << ": ";
+        for(int j = 0; j < 2; ++j){
+            std::cout << i_.m_values->m_data.at(j).m_value << " ";
+        }
+        std::cout << std::endl;
+    }
+
+    std::cout << "Prescale moddown ";
+    for(auto & i : PHatInvModp){
+        std::cout << i << " ";
+    }
+    std::cout << std::endl;
+    std::cout << "Matrix moddown ";
+    for(auto & i : PHatModq){
+        for(auto & j : i) {
+            std::cout << j << " ";
+        }
+        std::cout << std::endl;
+    }
+*/
 
     auto partPSwitchedToQ =
         partP.ApproxSwitchCRTBasis(paramsP, paramsQ, PHatInvModp, PHatInvModpPrecon, PHatModq, modqBarrettMu);
 
+
+/*
+    std::cout << "Output ModDown: \n";
+    for(auto & i_ : partPSwitchedToQ.m_vectors){
+        std::cout << i_.m_params->m_ciphertextModulus << " " << i_.m_params->m_rootOfUnity << ": ";
+        for(int j = 0; j < 2; ++j){
+            std::cout << i_.m_values->m_data.at(j).m_value << " ";
+        }
+        std::cout << std::endl;
+    }
+*/
+
     // Combine the switched DCRTPoly with the Q part of this to get the result
     DCRTPolyImpl<VecType> ans(paramsQ, Format::EVALUATION, true);
     uint32_t diffQ = paramsQ->GetParams().size() - sizeQ;
@@ -1016,7 +1083,18 @@ DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::ApproxModDown(
             partPSwitchedToQ.m_vectors[i] *= t;
         partPSwitchedToQ.m_vectors[i].SetFormat(Format::EVALUATION);
         ans.m_vectors[i] = (m_vectors[i] - partPSwitchedToQ.m_vectors[i]) * PInvModq[i];
+        //std::cout << PInvModq[i].m_value << " ";
     }
+/*
+    std::cout << " Output ModDown after sub mult: \n";
+    for(auto & i_ : ans.m_vectors){
+        std::cout << i_.m_params->m_ciphertextModulus << " " << i_.m_params->m_rootOfUnity << ": ";
+        for(int  j = 0; j < 2; ++j){
+            std::cout << i_.m_values->m_data.at(j).m_value << " ";
+        }
+        std::cout << std::endl;
+    }
+*/
     return ans;
 }
 
diff --git a/src/core/include/lattice/hal/default/dcrtpoly.h b/src/core/include/lattice/hal/default/dcrtpoly.h
index 2cf18e26..4c5ddbbe 100644
--- a/src/core/include/lattice/hal/default/dcrtpoly.h
+++ b/src/core/include/lattice/hal/default/dcrtpoly.h
@@ -391,7 +391,7 @@ public:
         m_vectors[index] = std::move(element);
     }
 
-protected:
+public:
     std::shared_ptr<Params> m_params{std::make_shared<DCRTPolyImpl::Params>()};
     Format m_format{Format::EVALUATION};
     std::vector<PolyType> m_vectors;
diff --git a/src/core/include/lattice/hal/default/ildcrtparams.h b/src/core/include/lattice/hal/default/ildcrtparams.h
index f8515747..939aa2bf 100644
--- a/src/core/include/lattice/hal/default/ildcrtparams.h
+++ b/src/core/include/lattice/hal/default/ildcrtparams.h
@@ -345,7 +345,7 @@ public:
         return 1;
     }
 
-private:
+public:
     std::ostream& doprint(std::ostream& out) const override {
         out << "ILDCRTParams ";
         ElemParams<IntType>::doprint(out);
diff --git a/src/core/include/lattice/hal/default/ilparams.h b/src/core/include/lattice/hal/default/ilparams.h
index ce18606f..50895eb5 100644
--- a/src/core/include/lattice/hal/default/ilparams.h
+++ b/src/core/include/lattice/hal/default/ilparams.h
@@ -152,7 +152,7 @@ public:
         return 1;
     }
 
-private:
+public:
     std::ostream& doprint(std::ostream& out) const override {
         out << "ILParams ";
         ElemParams<IntType>::doprint(out);
diff --git a/src/core/include/lattice/hal/default/poly-impl.h b/src/core/include/lattice/hal/default/poly-impl.h
index 48c47d24..ae80e7cc 100644
--- a/src/core/include/lattice/hal/default/poly-impl.h
+++ b/src/core/include/lattice/hal/default/poly-impl.h
@@ -422,6 +422,7 @@ void PolyImpl<VecType>::SwitchFormat() {
 
     if (m_format != Format::COEFFICIENT) {
         m_format = Format::COEFFICIENT;
+
         ChineseRemainderTransformFTT<VecType>().InverseTransformFromBitReverseInPlace(ru, co, &(*m_values));
         return;
     }
diff --git a/src/core/include/lattice/hal/default/poly.h b/src/core/include/lattice/hal/default/poly.h
index 411d2aae..e024da1a 100644
--- a/src/core/include/lattice/hal/default/poly.h
+++ b/src/core/include/lattice/hal/default/poly.h
@@ -354,7 +354,7 @@ public:
         return 1;
     }
 
-protected:
+public:
     Format m_format{Format::EVALUATION};
     std::shared_ptr<Params> m_params{nullptr};
     std::unique_ptr<VecType> m_values{nullptr};
diff --git a/src/core/include/lattice/hal/elemparams.h b/src/core/include/lattice/hal/elemparams.h
index 0538c60b..e062bb79 100644
--- a/src/core/include/lattice/hal/elemparams.h
+++ b/src/core/include/lattice/hal/elemparams.h
@@ -255,7 +255,7 @@ public:
         return 1;
     }
 
-protected:
+public:
     uint32_t m_ringDimension{0};
     uint32_t m_cyclotomicOrder{0};
     IntegerType m_ciphertextModulus{0};
diff --git a/src/core/include/lattice/hal/poly-interface.h b/src/core/include/lattice/hal/poly-interface.h
index 7d9089ac..32dc7e94 100644
--- a/src/core/include/lattice/hal/poly-interface.h
+++ b/src/core/include/lattice/hal/poly-interface.h
@@ -617,7 +617,7 @@ public:
         return this->GetDerived().GetElementName();
     }
 
-protected:
+public:
     /**
    * @brief ostream operator
    * @param os the input preceding output stream
diff --git a/src/core/include/lattice/trapdoorparameters.h b/src/core/include/lattice/trapdoorparameters.h
index 1de71af8..e4ea18c8 100644
--- a/src/core/include/lattice/trapdoorparameters.h
+++ b/src/core/include/lattice/trapdoorparameters.h
@@ -113,7 +113,7 @@ public:
         m_dgg.SetStd(stddev);
     }
 
-protected:
+public:
     double m_stddev;
     std::shared_ptr<ParmType> m_elemparams;
     DggType m_dgg;
@@ -221,7 +221,7 @@ public:
         m_dggLargeSigma = dggLargeSigma;
     }
 
-protected:
+public:
     int64_t m_base;
     size_t m_k;
     bool m_bal;
@@ -261,7 +261,7 @@ public:
         return m_pvector;
     }
 
-private:
+public:
     // Perturbation vector represented as a vector of ring elements
     std::shared_ptr<Matrix<Element>> m_pvector;
 };
diff --git a/src/core/include/math/binaryuniformgenerator.h b/src/core/include/math/binaryuniformgenerator.h
index e254cab1..98c1c035 100644
--- a/src/core/include/math/binaryuniformgenerator.h
+++ b/src/core/include/math/binaryuniformgenerator.h
@@ -71,7 +71,7 @@ public:
    */
     VecType GenerateVector(const usint size, const typename VecType::Integer& modulus) const;
 
-private:
+public:
     static std::bernoulli_distribution m_distribution;
 };
 
diff --git a/src/core/include/math/dftransform.h b/src/core/include/math/dftransform.h
index d4ed3000..f747f911 100644
--- a/src/core/include/math/dftransform.h
+++ b/src/core/include/math/dftransform.h
@@ -109,7 +109,7 @@ public:
 
     static void Initialize(uint32_t m, uint32_t nh);
 
-private:
+public:
     static std::complex<double>* rootOfUnityTable;
 
     // structure to keep values precomputed by Initialize() for every cyclotomic order value
diff --git a/src/core/include/math/discretegaussiangenerator.h b/src/core/include/math/discretegaussiangenerator.h
index 6ecd265b..71f9f1c3 100644
--- a/src/core/include/math/discretegaussiangenerator.h
+++ b/src/core/include/math/discretegaussiangenerator.h
@@ -190,7 +190,7 @@ public:
    */
     static int64_t GenerateIntegerKarney(double mean, double stddev);
 
-private:
+public:
     // Gyana to add precomputation methods and data members
     // all parameters are set as int because it is assumed that they are used for
     // generating "small" polynomials only
diff --git a/src/core/include/math/discretegaussiangeneratorgeneric.h b/src/core/include/math/discretegaussiangeneratorgeneric.h
index a07f2a9b..003c50e0 100644
--- a/src/core/include/math/discretegaussiangeneratorgeneric.h
+++ b/src/core/include/math/discretegaussiangeneratorgeneric.h
@@ -137,7 +137,7 @@ public:
         return static_cast<short>((m_sequence >> (--m_counter)) & 0x1);  // NOLINT
     }
 
-private:
+public:
     uint32_t m_sequence{0};
     uint32_t m_counter{0};
 };
@@ -174,7 +174,7 @@ public:
         return bg->Generate();
     }
 
-private:
+public:
     // all parameters are set as int because it is assumed that they are used for
     // generating "small" polynomials only
     double b_a;
@@ -286,7 +286,7 @@ public:
    */
     ~SamplerCombiner() = default;
 
-private:
+public:
     // Samplers to be combined
     BaseSampler *sampler1, *sampler2;
     // Coefficients that are used for combining
@@ -324,7 +324,7 @@ public:
    */
     ~DiscreteGaussianGeneratorGeneric();
 
-private:
+public:
     /**
    * @brief Subroutine used by Sample C
    * @param center Center of the distribution
diff --git a/src/core/include/math/discreteuniformgenerator.h b/src/core/include/math/discreteuniformgenerator.h
index 61c1a650..9f07e0fa 100644
--- a/src/core/include/math/discreteuniformgenerator.h
+++ b/src/core/include/math/discreteuniformgenerator.h
@@ -76,7 +76,7 @@ public:
     VecType GenerateVector(const uint32_t size) const;
     VecType GenerateVector(const uint32_t size, const typename VecType::Integer& modulus);
 
-private:
+public:
     typename VecType::Integer m_modulus{};
     uint32_t m_chunksPerValue{};
     uint32_t m_shiftChunk{};
diff --git a/src/core/include/math/hal/bigintdyn/mubintvecdyn.h b/src/core/include/math/hal/bigintdyn/mubintvecdyn.h
index f42da182..1250bcec 100644
--- a/src/core/include/math/hal/bigintdyn/mubintvecdyn.h
+++ b/src/core/include/math/hal/bigintdyn/mubintvecdyn.h
@@ -625,7 +625,7 @@ public:
         return 1;
     }
 
-private:
+public:
     enum State { GARBAGE, INITIALIZED };
 
     ubint_el_t m_modulus{};
diff --git a/src/core/include/math/hal/bigintdyn/ubintdyn.h b/src/core/include/math/hal/bigintdyn/ubintdyn.h
index cffc6fca..03181720 100644
--- a/src/core/include/math/hal/bigintdyn/ubintdyn.h
+++ b/src/core/include/math/hal/bigintdyn/ubintdyn.h
@@ -140,7 +140,7 @@ struct DataTypes<uint128_t> {
 
 template <typename limb_t>
 class ubint final : public lbcrypto::BigIntegerInterface<ubint<limb_t>> {
-private:
+public:
     // variable that stores the MOST SIGNIFICANT BIT position in the
     usint m_MSB{0};
     // vector storing the native integers. stored little endian
@@ -922,7 +922,7 @@ public:
         return 1;
     }
 
-private:
+public:
     /**
    * Sets the MSB to the correct value as computed from the internal value.
    */
diff --git a/src/core/include/math/hal/bigintfxd/ubintfxd.h b/src/core/include/math/hal/bigintfxd/ubintfxd.h
index b917c4c3..c7c77184 100644
--- a/src/core/include/math/hal/bigintfxd/ubintfxd.h
+++ b/src/core/include/math/hal/bigintfxd/ubintfxd.h
@@ -1097,7 +1097,7 @@ public:
         return 1;
     }
 
-protected:
+public:
     /**
    * Converts the string v into base-r integer where r is equal to 2^bitwidth of
    * integral data type.
@@ -1117,7 +1117,7 @@ protected:
    */
     void SetMSB(usint guessIdxChar);
 
-private:
+public:
     // array storing the native integers.
     // array size is the ceiling of BITLENGTH/(bits in the integral data type)
     uint_type m_value[(BITLENGTH + 8 * sizeof(uint_type) - 1) / (8 * sizeof(uint_type))];
diff --git a/src/core/include/math/hal/bigintntl/mubintvecntl.h b/src/core/include/math/hal/bigintntl/mubintvecntl.h
index 2c8262c3..9d61e398 100644
--- a/src/core/include/math/hal/bigintntl/mubintvecntl.h
+++ b/src/core/include/math/hal/bigintntl/mubintvecntl.h
@@ -735,7 +735,7 @@ private:
     // enum to store the state of the
     ModulusState m_modulus_state;
 
-protected:
+public:
     bool IndexCheck(size_t index) const {
         return index < this->GetLength();
     }
diff --git a/src/core/include/math/hal/bigintntl/ubintntl.h b/src/core/include/math/hal/bigintntl/ubintntl.h
index f0199582..6ae8fce3 100644
--- a/src/core/include/math/hal/bigintntl/ubintntl.h
+++ b/src/core/include/math/hal/bigintntl/ubintntl.h
@@ -1068,7 +1068,7 @@ public:
         return 1;
     }
 
-private:
+public:
     // adapter kits
     void SetMSB();
 
diff --git a/src/core/include/math/hal/intnat/mubintvecnat.h b/src/core/include/math/hal/intnat/mubintvecnat.h
index abc48d84..c2f60c70 100644
--- a/src/core/include/math/hal/intnat/mubintvecnat.h
+++ b/src/core/include/math/hal/intnat/mubintvecnat.h
@@ -119,7 +119,7 @@ bool operator!=(const NAlloc<T>&, const NAlloc<U>&) { return false; }
 template <class IntegerType>
 class NativeVectorT final : public lbcrypto::BigVectorInterface<NativeVectorT<IntegerType>, IntegerType>,
                             public lbcrypto::Serializable {
-private:
+public:
     // m_modulus stores the internal modulus of the vector.
     IntegerType m_modulus{0};
 
diff --git a/src/core/include/math/hal/intnat/ubintnat.h b/src/core/include/math/hal/intnat/ubintnat.h
index c5b6216a..52ccf570 100644
--- a/src/core/include/math/hal/intnat/ubintnat.h
+++ b/src/core/include/math/hal/intnat/ubintnat.h
@@ -130,7 +130,7 @@ struct DataTypes<uint128_t> {
  */
 template <typename NativeInt>
 class NativeIntegerT final : public lbcrypto::BigIntegerInterface<NativeIntegerT<NativeInt>> {
-private:
+public:
     NativeInt m_value{0};
 
     // variable to store the maximum value of the integral data type.
@@ -1873,7 +1873,7 @@ public:
         return true;
     }
 
-private:
+public:
     // Computes res -= a;
     static void SubtractD(typeD& res, const typeD& a) {
         if (res.lo < a.lo) {
diff --git a/src/core/include/utils/parallel.h b/src/core/include/utils/parallel.h
index a489b7c0..88f8dfcc 100644
--- a/src/core/include/utils/parallel.h
+++ b/src/core/include/utils/parallel.h
@@ -35,7 +35,7 @@
 
 #ifndef SRC_CORE_LIB_UTILS_PARALLEL_H_
 #define SRC_CORE_LIB_UTILS_PARALLEL_H_
-
+#include <cerrno>
 #ifdef PARALLEL
     #include <omp.h>
 #endif
diff --git a/src/core/include/utils/sertype.h b/src/core/include/utils/sertype.h
index 4c843ecc..45457f8d 100644
--- a/src/core/include/utils/sertype.h
+++ b/src/core/include/utils/sertype.h
@@ -41,7 +41,10 @@ namespace lbcrypto {
 namespace SerType {
 
 class SERJSON {};
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunneeded-internal-declaration"
 static const SERJSON JSON;  // should be const static to avoid compilation failure
+#pragma clang diagnostic pop
 
 class SERBINARY {};
 static const SERBINARY BINARY;  // should be const static to avoid compilation failure
diff --git a/src/core/lib/math/chebyshev.cpp b/src/core/lib/math/chebyshev.cpp
index 907cb42e..a2fe36b0 100644
--- a/src/core/lib/math/chebyshev.cpp
+++ b/src/core/lib/math/chebyshev.cpp
@@ -67,4 +67,6 @@ std::vector<double> EvalChebyshevCoefficients(std::function<double(double)> func
     return coefficients;
 }
 
+
+
 }  // namespace lbcrypto
diff --git a/src/core/lib/math/distributiongenerator.cpp b/src/core/lib/math/distributiongenerator.cpp
index 570f6e89..f83d73ce 100644
--- a/src/core/lib/math/distributiongenerator.cpp
+++ b/src/core/lib/math/distributiongenerator.cpp
@@ -34,6 +34,7 @@
   all other distribution generators
  */
 
+#include <cerrno>
 #include "math/distributiongenerator.h"
 #include "utils/prng/blake2engine.h"
 #include "utils/exception.h"
diff --git a/src/core/lib/math/hal/intnat/mubintvecnat.cpp b/src/core/lib/math/hal/intnat/mubintvecnat.cpp
index c231f802..c1542475 100644
--- a/src/core/lib/math/hal/intnat/mubintvecnat.cpp
+++ b/src/core/lib/math/hal/intnat/mubintvecnat.cpp
@@ -113,6 +113,7 @@ void NativeVectorT<IntegerType>::SwitchModulus(const IntegerType& modulus) {
     auto om{m_modulus.m_value};
     this->NativeVectorT::SetModulus(modulus);
     auto nm{modulus.m_value};
+
     if (nm > om) {
         auto diff{nm - om};
         for (size_t i = 0; i < size; ++i) {
@@ -131,6 +132,7 @@ void NativeVectorT<IntegerType>::SwitchModulus(const IntegerType& modulus) {
                 v = v % nm;
         }
     }
+
 }
 
 template <class IntegerType>
diff --git a/src/core/lib/math/nbtheory2.cpp b/src/core/lib/math/nbtheory2.cpp
index d4b55ee6..056a64b1 100644
--- a/src/core/lib/math/nbtheory2.cpp
+++ b/src/core/lib/math/nbtheory2.cpp
@@ -273,16 +273,20 @@ uint32_t FindAutomorphismIndex2nComplex(int32_t i, uint32_t m) {
 }
 
 void PrecomputeAutoMap(uint32_t n, uint32_t k, std::vector<uint32_t>* precomp) {
+
+    // std::cout << n << " " << k << std::endl;
     uint32_t m    = n << 1;  // cyclOrder
     uint32_t logm = std::round(log2(m));
     uint32_t logn = std::round(log2(n));
     for (uint32_t j = 0; j < n; j++) {
         uint32_t jTmp    = ((j << 1) + 1);
         usint idx        = ((jTmp * k) - (((jTmp * k) >> logm) << logm)) >> 1;
+     //   std::cout << "(" << j << " " << idx << ") ";
         usint jrev       = ReverseBits(j, logn);
         usint idxrev     = ReverseBits(idx, logn);
         (*precomp)[jrev] = idxrev;
     }
+   // std::cout << std::endl;
 }
 
 }  // namespace lbcrypto
diff --git a/src/pke/include/ciphertext.h b/src/pke/include/ciphertext.h
index 59273b34..f4e026e4 100644
--- a/src/pke/include/ciphertext.h
+++ b/src/pke/include/ciphertext.h
@@ -587,7 +587,7 @@ public:
         return 1;
     }
 
-private:
+public:
     // vector of ring elements for this Ciphertext
     std::vector<Element> m_elements;
 
diff --git a/src/pke/include/cryptocontext.h b/src/pke/include/cryptocontext.h
index 8c4413e2..692fe71d 100644
--- a/src/pke/include/cryptocontext.h
+++ b/src/pke/include/cryptocontext.h
@@ -250,12 +250,13 @@ class CryptoContextImpl : public Serializable {
     static std::shared_ptr<std::map<usint, EvalKey<Element>>> GetPartialEvalAutomorphismKeyMapPtr(
         const std::string& keyID, const std::vector<uint32_t>& indexList);
 
+public:
     // cached evalmult keys, by secret key UID
     static std::map<std::string, std::vector<EvalKey<Element>>> s_evalMultKeyMap;
     // cached evalautomorphism keys, by secret key UID
     static std::map<std::string, std::shared_ptr<std::map<usint, EvalKey<Element>>>> s_evalAutomorphismKeyMap;
 
-protected:
+public:
     // crypto parameters used for this context
     std::shared_ptr<CryptoParametersBase<Element>> params{nullptr};
     // algorithm used; accesses all crypto methods
@@ -3300,8 +3301,8 @@ public:
    * @param precompute - flag specifying whether to precompute the plaintexts for encoding and decoding.
    */
     void EvalBootstrapSetup(std::vector<uint32_t> levelBudget = {5, 4}, std::vector<uint32_t> dim1 = {0, 0},
-                            uint32_t slots = 0, uint32_t correctionFactor = 0, bool precompute = true) {
-        GetScheme()->EvalBootstrapSetup(*this, levelBudget, dim1, slots, correctionFactor, precompute);
+                            uint32_t slots = 0, uint32_t correctionFactor = 0, bool precompute = true, int32_t modevallevels = -1) {
+        GetScheme()->EvalBootstrapSetup(*this, levelBudget, dim1, slots, correctionFactor, precompute, modevallevels);
     }
     /**
    * Generates all automorphism keys for EvalBootstrap. Supported in CKKS only.
@@ -3696,6 +3697,7 @@ public:
     static uint32_t SerializedVersion() {
         return 1;
     }
+
 };
 
 // Member function specializations. Their implementations are in cryptocontext.cpp
@@ -3706,6 +3708,8 @@ template <>
 std::unordered_map<uint32_t, DCRTPoly> CryptoContextImpl<DCRTPoly>::ShareKeys(const PrivateKey<DCRTPoly>& sk, usint N,
                                                                               usint threshold, usint index,
                                                                               const std::string& shareType) const;
+
+
 }  // namespace lbcrypto
 
 #endif /* SRC_PKE_CRYPTOCONTEXT_H_ */
diff --git a/src/pke/include/cryptocontextfactory.h b/src/pke/include/cryptocontextfactory.h
index 3cca987e..666ab402 100644
--- a/src/pke/include/cryptocontextfactory.h
+++ b/src/pke/include/cryptocontextfactory.h
@@ -57,7 +57,7 @@ template <typename Element>
 class CryptoContextFactory {
     static std::vector<CryptoContext<Element>> AllContexts;
 
-protected:
+public:
     static CryptoContext<Element> FindContext(std::shared_ptr<CryptoParametersBase<Element>> params,
                                               std::shared_ptr<SchemeBase<Element>> scheme);
     static void AddContext(CryptoContext<Element>);
diff --git a/src/pke/include/cryptoobject.h b/src/pke/include/cryptoobject.h
index 4323d2b6..2c849763 100644
--- a/src/pke/include/cryptoobject.h
+++ b/src/pke/include/cryptoobject.h
@@ -51,7 +51,7 @@ namespace lbcrypto {
  */
 template <typename Element>
 class CryptoObject {
-protected:
+public:
     CryptoContext<Element> context;  // crypto context belongs to the tag used to find the evaluation key needed
                                      // for SHE/FHE operations
     std::string keyTag;
diff --git a/src/pke/include/encoding/ckkspackedencoding.h b/src/pke/include/encoding/ckkspackedencoding.h
index 4a323702..d4dec1da 100644
--- a/src/pke/include/encoding/ckkspackedencoding.h
+++ b/src/pke/include/encoding/ckkspackedencoding.h
@@ -278,7 +278,7 @@ private:
 
     double m_logError = 0;
 
-protected:
+public:
     usint GetDefaultSlotSize() {
         auto batchSize = GetEncodingParams()->GetBatchSize();
         return (0 == batchSize) ? GetElementRingDimension() / 2 : batchSize;
diff --git a/src/pke/include/encoding/encodingparams.h b/src/pke/include/encoding/encodingparams.h
index cd213c38..d54f14d7 100644
--- a/src/pke/include/encoding/encodingparams.h
+++ b/src/pke/include/encoding/encodingparams.h
@@ -253,7 +253,7 @@ public:
         return !(*this == other);
     }
 
-private:
+public:
     std::ostream& doprint(std::ostream& out) const {
         out << "[p=" << m_plaintextModulus << " rootP =" << m_plaintextRootOfUnity << " bigP =" << m_plaintextBigModulus
             << " rootBigP =" << m_plaintextBigRootOfUnity << " g=" << m_plaintextGenerator << " L=" << m_batchSize
diff --git a/src/pke/include/encoding/packedencoding.h b/src/pke/include/encoding/packedencoding.h
index 97a02c4a..104894cd 100644
--- a/src/pke/include/encoding/packedencoding.h
+++ b/src/pke/include/encoding/packedencoding.h
@@ -199,7 +199,7 @@ public:
         out << " ... )";
     }
 
-private:
+public:
     // initial root of unity for plaintext space
     static std::map<ModulusM, NativeInteger> m_initRoot;
     // modulus and root of unity to be used for Arbitrary CRT
diff --git a/src/pke/include/encoding/plaintext.h b/src/pke/include/encoding/plaintext.h
index efd18cc8..a511907a 100644
--- a/src/pke/include/encoding/plaintext.h
+++ b/src/pke/include/encoding/plaintext.h
@@ -62,7 +62,7 @@ namespace lbcrypto {
  * It provides virtual methods for encoding and decoding of data.
  */
 class PlaintextImpl {
-protected:
+public:
     enum PtxtPolyType { IsPoly, IsDCRTPoly, IsNativePoly };
 
     bool isEncoded;
@@ -216,7 +216,7 @@ public:
     int64_t LowBound() const {
         uint64_t half = GetEncodingParams()->GetPlaintextModulus() >> 1;
         bool odd      = (GetEncodingParams()->GetPlaintextModulus() & 0x1) == 1;
-        int64_t bound = -1 * half;
+        int64_t bound = -1 * static_cast<int64_t>(half);
         if (odd)
             bound--;
         return bound;
diff --git a/src/pke/include/key/evalkeyrelin.h b/src/pke/include/key/evalkeyrelin.h
index e5fa75b4..8cca31d3 100644
--- a/src/pke/include/key/evalkeyrelin.h
+++ b/src/pke/include/key/evalkeyrelin.h
@@ -278,7 +278,7 @@ public:
         return 1;
     }
 
-private:
+public:
     // private member to store vector of vector of Element.
     std::vector<std::vector<Element>> m_rKey;
 
diff --git a/src/pke/include/key/privatekey.h b/src/pke/include/key/privatekey.h
index 86996925..13e04bb1 100644
--- a/src/pke/include/key/privatekey.h
+++ b/src/pke/include/key/privatekey.h
@@ -177,7 +177,7 @@ public:
         return 1;
     }
 
-private:
+public:
     Element m_sk;
 };
 
diff --git a/src/pke/include/key/publickey.h b/src/pke/include/key/publickey.h
index ca6ef34b..7ae8d6ba 100644
--- a/src/pke/include/key/publickey.h
+++ b/src/pke/include/key/publickey.h
@@ -196,7 +196,7 @@ public:
         return 1;
     }
 
-private:
+public:
     std::vector<Element> m_h;
 };
 
diff --git a/src/pke/include/scheme/bfvrns/bfvrns-leveledshe.h b/src/pke/include/scheme/bfvrns/bfvrns-leveledshe.h
index f0e6dc6e..cb7e0f4e 100644
--- a/src/pke/include/scheme/bfvrns/bfvrns-leveledshe.h
+++ b/src/pke/include/scheme/bfvrns/bfvrns-leveledshe.h
@@ -139,7 +139,7 @@ public:
         return "LeveledSHEBFVRNS";
     }
 
-private:
+public:
     void RelinearizeCore(Ciphertext<DCRTPoly>& ciphertext, const EvalKey<DCRTPoly> evalKey) const;
 };
 }  // namespace lbcrypto
diff --git a/src/pke/include/scheme/bgvrns/bgvrns-parametergeneration.h b/src/pke/include/scheme/bgvrns/bgvrns-parametergeneration.h
index ade5044e..e4c39200 100644
--- a/src/pke/include/scheme/bgvrns/bgvrns-parametergeneration.h
+++ b/src/pke/include/scheme/bgvrns/bgvrns-parametergeneration.h
@@ -112,7 +112,7 @@ public:
         return "ParameterGenerationBGVRNS";
     }
 
-private:
+public:
     /*
    * Method that computes a security-compliant ring dimension.
    *
diff --git a/src/pke/include/scheme/ckksrns/ckksrns-fhe.h b/src/pke/include/scheme/ckksrns/ckksrns-fhe.h
index 7cb17704..a0c39271 100644
--- a/src/pke/include/scheme/ckksrns/ckksrns-fhe.h
+++ b/src/pke/include/scheme/ckksrns/ckksrns-fhe.h
@@ -142,14 +142,23 @@ public:
     //------------------------------------------------------------------------------
 
     void EvalBootstrapSetup(const CryptoContextImpl<DCRTPoly>& cc, std::vector<uint32_t> levelBudget,
-                            std::vector<uint32_t> dim1, uint32_t slots, uint32_t correctionFactor,
-                            bool precompute) override;
+                            std::vector<uint32_t> dim1, uint32_t slots, uint32_t correctionFactor, bool precompute,
+                            int32_t modevallevels = -1) override;
 
     std::shared_ptr<std::map<usint, EvalKey<DCRTPoly>>> EvalBootstrapKeyGen(const PrivateKey<DCRTPoly> privateKey,
                                                                             uint32_t slots) override;
 
     void EvalBootstrapPrecompute(const CryptoContextImpl<DCRTPoly>& cc, uint32_t slots) override;
 
+    Ciphertext<DCRTPoly> EvalBootstrapNoStC(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                                        uint32_t precision) const;
+
+    std::pair<Ciphertext<DCRTPoly>, Ciphertext<DCRTPoly>> EvalBootstrapDensePartial(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                       uint32_t precision) const;
+
+    Ciphertext<DCRTPoly> EvalBootstrapSetupOnly(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                                                                    uint32_t precision) const;
+
     Ciphertext<DCRTPoly> EvalBootstrap(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
                                        uint32_t precision) const override;
 
@@ -171,13 +180,13 @@ public:
 
     std::vector<ConstPlaintext> EvalLinearTransformPrecompute(const CryptoContextImpl<DCRTPoly>& cc,
                                                               const std::vector<std::vector<std::complex<double>>>& A,
-                                                              double scale = 1, uint32_t L = 0) const;
+                                                              double scale = 1, uint32_t L = 0, bool extended = true) const;
 
     std::vector<ConstPlaintext> EvalLinearTransformPrecompute(const CryptoContextImpl<DCRTPoly>& cc,
                                                               const std::vector<std::vector<std::complex<double>>>& A,
                                                               const std::vector<std::vector<std::complex<double>>>& B,
                                                               uint32_t orientation = 0, double scale = 1,
-                                                              uint32_t L = 0) const;
+                                                              uint32_t L = 0, bool extended = true) const;
 
     std::vector<std::vector<ConstPlaintext>> EvalCoeffsToSlotsPrecompute(const CryptoContextImpl<DCRTPoly>& cc,
                                                                          const std::vector<std::complex<double>>& A,
@@ -231,7 +240,7 @@ public:
         return "FHECKKSRNS";
     }
 
-private:
+public:
     //------------------------------------------------------------------------------
     // Auxiliary Bootstrap Functions
     //------------------------------------------------------------------------------
@@ -241,7 +250,7 @@ private:
 
     void AdjustCiphertext(Ciphertext<DCRTPoly>& ciphertext, double correction) const;
 
-    void ApplyDoubleAngleIterations(Ciphertext<DCRTPoly>& ciphertext, uint32_t numIt) const;
+    static void ApplyDoubleAngleIterations(Ciphertext<DCRTPoly>& ciphertext, uint32_t numIt) ;
 
     Plaintext MakeAuxPlaintext(const CryptoContextImpl<DCRTPoly>& cc, const std::shared_ptr<ParmType> params,
                                const std::vector<std::complex<double>>& value, size_t noiseScaleDeg, uint32_t level,
diff --git a/src/pke/include/scheme/ckksrns/ckksrns-schemeswitching.h b/src/pke/include/scheme/ckksrns/ckksrns-schemeswitching.h
index 1452e628..07c9cc3f 100644
--- a/src/pke/include/scheme/ckksrns/ckksrns-schemeswitching.h
+++ b/src/pke/include/scheme/ckksrns/ckksrns-schemeswitching.h
@@ -184,7 +184,7 @@ public:
         return "SWITCHCKKSRNS";
     }
 
-private:
+public:
     std::vector<ConstPlaintext> EvalLTPrecomputeSwitch(const CryptoContextImpl<DCRTPoly>& cc,
                                                        const std::vector<std::vector<std::complex<double>>>& A,
                                                        uint32_t dim1, uint32_t L, double scale) const;
diff --git a/src/pke/include/scheme/gen-cryptocontext-params.h b/src/pke/include/scheme/gen-cryptocontext-params.h
index c78a8edc..b3f2695b 100644
--- a/src/pke/include/scheme/gen-cryptocontext-params.h
+++ b/src/pke/include/scheme/gen-cryptocontext-params.h
@@ -169,7 +169,7 @@ class Params {
 
     void SetToDefaults(SCHEME scheme);
 
-protected:
+public:
     // How to disable a particular setter for a particular scheme and get an exception thrown if a user tries to call it:
     // 1. The set function should be declared virtual in this file
     // 2. The same function should be re-defined in the scheme-specific derived file using macros DISABLED_FOR_xxxxRNS defined below.
diff --git a/src/pke/include/schemebase/base-advancedshe.h b/src/pke/include/schemebase/base-advancedshe.h
index 77b013cb..1aeee2f1 100644
--- a/src/pke/include/schemebase/base-advancedshe.h
+++ b/src/pke/include/schemebase/base-advancedshe.h
@@ -334,7 +334,7 @@ public:
     // Other Methods for Bootstrap
     //------------------------------------------------------------------------------
 
-protected:
+public:
     std::set<uint32_t> GenerateIndices_2n(usint batchSize, usint m) const;
 
     std::set<uint32_t> GenerateIndices2nComplex(usint batchSize, usint m) const;
diff --git a/src/pke/include/schemebase/base-cryptoparameters.h b/src/pke/include/schemebase/base-cryptoparameters.h
index 76a1bf17..f4254767 100644
--- a/src/pke/include/schemebase/base-cryptoparameters.h
+++ b/src/pke/include/schemebase/base-cryptoparameters.h
@@ -174,7 +174,7 @@ public:
         return 1;
     }
 
-protected:
+public:
     explicit CryptoParametersBase(const PlaintextModulus& plaintextModulus) {
         m_encodingParams = std::make_shared<EncodingParamsImpl>(plaintextModulus);
     }
@@ -199,7 +199,7 @@ protected:
         out << "Encoding Parameters: " << *m_encodingParams << std::endl;
     }
 
-protected:
+public:
     // element-specific parameters
     std::shared_ptr<typename Element::Params> m_params;
 
diff --git a/src/pke/include/schemebase/base-fhe.h b/src/pke/include/schemebase/base-fhe.h
index 761620bc..16e0bdf1 100644
--- a/src/pke/include/schemebase/base-fhe.h
+++ b/src/pke/include/schemebase/base-fhe.h
@@ -81,10 +81,11 @@ public:
    * @param slots - number of slots to be bootstrapped
    * @param correctionFactor - value to rescale message by to improve precision. If set to 0, we use the default logic. This value is only used when NATIVE_SIZE=64
    * @param precompute - flag specifying whether to precompute the plaintexts for encoding and decoding.
+   * @param modevallevels
    */
     virtual void EvalBootstrapSetup(const CryptoContextImpl<Element>& cc, std::vector<uint32_t> levelBudget,
                                     std::vector<uint32_t> dim1, uint32_t slots, uint32_t correctionFactor,
-                                    bool precompute) {
+                                    bool precompute, int32_t modevallevels = -1) {
         OPENFHE_THROW("Not supported");
     }
 
diff --git a/src/pke/include/schemebase/base-leveledshe.h b/src/pke/include/schemebase/base-leveledshe.h
index 2ab99daa..0ca418f0 100644
--- a/src/pke/include/schemebase/base-leveledshe.h
+++ b/src/pke/include/schemebase/base-leveledshe.h
@@ -779,7 +779,7 @@ public:
 
     virtual Ciphertext<Element> MorphPlaintext(ConstPlaintext plaintext, ConstCiphertext<Element> ciphertext) const;
 
-protected:
+public:
     /////////////////////////////////////////
     // CORE OPERATIONS
     /////////////////////////////////////////
diff --git a/src/pke/include/schemebase/base-scheme.h b/src/pke/include/schemebase/base-scheme.h
index 736a7edc..db664ea0 100644
--- a/src/pke/include/schemebase/base-scheme.h
+++ b/src/pke/include/schemebase/base-scheme.h
@@ -48,6 +48,7 @@
 
 #include "utils/exception.h"
 #include "utils/caller_info.h"
+#include "scheme/ckksrns/ckksrns-fhe.h"
 
 #include <vector>
 #include <map>
@@ -78,7 +79,7 @@ class SchemeBase {
     using DggType  = typename Element::DggType;
     using TugType  = typename Element::TugType;
 
-protected:
+public:
     inline void CheckMultipartyDecryptCompatibility(ConstCiphertext<Element>& ciphertext, CALLER_INFO_ARGS_HDR) const {
         if (ciphertext->NumberCiphertextElements() > 2) {
             std::string errorMsg(std::string("ciphertext's number of elements is [") +
@@ -1384,9 +1385,9 @@ public:
 
     void EvalBootstrapSetup(const CryptoContextImpl<Element>& cc, const std::vector<uint32_t>& levelBudget = {5, 4},
                             const std::vector<uint32_t>& dim1 = {0, 0}, uint32_t slots = 0,
-                            uint32_t correctionFactor = 0, bool precompute = true) {
+                            uint32_t correctionFactor = 0, bool precompute = true, int32_t modevallevels = -1) {
         VerifyFHEEnabled(__func__);
-        m_FHE->EvalBootstrapSetup(cc, levelBudget, dim1, slots, correctionFactor, precompute);
+        m_FHE->EvalBootstrapSetup(cc, levelBudget, dim1, slots, correctionFactor, precompute, modevallevels);
         return;
     }
 
@@ -1408,6 +1409,14 @@ public:
         return m_FHE->EvalBootstrap(ciphertext, numIterations, precision);
     }
 
+    std::pair<Ciphertext<Element>, Ciphertext<Element>>
+            EvalBootstrapDensePartial(ConstCiphertext<Element> ciphertext, uint32_t numIterations = 1,
+                                      uint32_t precision = 0) const {
+        VerifyFHEEnabled(__func__);
+
+        return dynamic_cast<lbcrypto::FHECKKSRNS *>(m_FHE.get())->EvalBootstrapDensePartial(ciphertext, numIterations, precision);
+    }
+
     // SCHEMESWITCHING methods
 
     LWEPrivateKey EvalCKKStoFHEWSetup(const SchSwchParams& params) {
@@ -1711,7 +1720,7 @@ public:
         return out;
     }
 
-protected:
+public:
     std::shared_ptr<ParameterGenerationBase<Element>> m_ParamsGen;
     std::shared_ptr<PKEBase<Element>> m_PKE;
     std::shared_ptr<KeySwitchBase<Element>> m_KeySwitch;
diff --git a/src/pke/include/schemebase/rlwe-cryptoparameters.h b/src/pke/include/schemebase/rlwe-cryptoparameters.h
index cb8c2c55..3603c5e6 100644
--- a/src/pke/include/schemebase/rlwe-cryptoparameters.h
+++ b/src/pke/include/schemebase/rlwe-cryptoparameters.h
@@ -495,7 +495,7 @@ public:
         return "CryptoParametersRLWE";
     }
 
-protected:
+public:
     // standard deviation in Discrete Gaussian Distribution
     float m_distributionParameter = 0;
     // standard deviation in Discrete Gaussian Distribution with Flooding
diff --git a/src/pke/include/schemerns/rns-cryptoparameters.h b/src/pke/include/schemerns/rns-cryptoparameters.h
index 0d07d7db..6720ca98 100644
--- a/src/pke/include/schemerns/rns-cryptoparameters.h
+++ b/src/pke/include/schemerns/rns-cryptoparameters.h
@@ -57,7 +57,7 @@ namespace lbcrypto {
 class CryptoParametersRNS : public CryptoParametersRLWE<DCRTPoly> {
     using ParmType = typename DCRTPoly::Params;
 
-protected:
+public:
     CryptoParametersRNS()
         : CryptoParametersRLWE<DCRTPoly>(),
           m_ksTechnique(BV),
@@ -1348,7 +1348,7 @@ public:
         return m_MPIntBootCiphertextCompressionLevel;
     }
 
-protected:
+public:
     /////////////////////////////////////
     // PrecomputeCRTTables
     /////////////////////////////////////
diff --git a/src/pke/include/schemerns/rns-leveledshe.h b/src/pke/include/schemerns/rns-leveledshe.h
index 37b71f38..23dd980e 100644
--- a/src/pke/include/schemerns/rns-leveledshe.h
+++ b/src/pke/include/schemerns/rns-leveledshe.h
@@ -291,7 +291,7 @@ public:
 
     Ciphertext<DCRTPoly> Compress(ConstCiphertext<DCRTPoly> ciphertext, size_t towersLeft) const override;
 
-protected:
+public:
     /////////////////////////////////////
     // RNS Core
     /////////////////////////////////////
diff --git a/src/pke/include/schemerns/rns-parametergeneration.h b/src/pke/include/schemerns/rns-parametergeneration.h
index d7fadd17..69da3d1c 100644
--- a/src/pke/include/schemerns/rns-parametergeneration.h
+++ b/src/pke/include/schemerns/rns-parametergeneration.h
@@ -128,7 +128,7 @@ public:
         return "ParameterGenerationRNS";
     }
 
-protected:
+public:
     enum DCRT_MODULUS {
         DEFAULT_EXTRA_MOD_SIZE = 20,
         MIN_SIZE               = 14,
diff --git a/src/pke/lib/cryptocontext.cpp b/src/pke/lib/cryptocontext.cpp
index 2d22aff5..47fde1bf 100644
--- a/src/pke/lib/cryptocontext.cpp
+++ b/src/pke/lib/cryptocontext.cpp
@@ -37,7 +37,7 @@
 
 #include "key/privatekey.h"
 #include "key/publickey.h"
-#include "math/chebyshev.h"
+//#include "chebyshev.h"
 #include "schemerns/rns-scheme.h"
 #include "scheme/ckksrns/ckksrns-cryptoparameters.h"
 
@@ -509,11 +509,35 @@ DecryptResult CryptoContextImpl<Element>::Decrypt(ConstCiphertext<Element> ciphe
 // Advanced SHE CHEBYSHEV SERIES EXAMPLES
 //------------------------------------------------------------------------------
 
+std::vector<double> EvalChebyshevCoefficients(std::function<double(double)> func, double a, double b, uint32_t degree) {
+    if (!degree) {
+        OPENFHE_THROW("The degree of approximation can not be zero");
+    }
+    // the number of coefficients to be generated should be degree+1 as zero is also included
+    size_t coeffTotal{degree + 1};
+    double bMinusA = 0.5 * (b - a);
+    double bPlusA  = 0.5 * (b + a);
+    double PiByDeg = M_PI / static_cast<double>(coeffTotal);
+    std::vector<double> functionPoints(coeffTotal);
+    for (size_t i = 0; i < coeffTotal; ++i)
+        functionPoints[i] = func(std::cos(PiByDeg * (i + 0.5)) * bMinusA + bPlusA);
+
+    double multFactor = 2.0 / static_cast<double>(coeffTotal);
+    std::vector<double> coefficients(coeffTotal);
+    for (size_t i = 0; i < coeffTotal; ++i) {
+        for (size_t j = 0; j < coeffTotal; ++j)
+            coefficients[i] += functionPoints[j] * std::cos(PiByDeg * i * (j + 0.5));
+        coefficients[i] *= multFactor;
+    }
+    return coefficients;
+}
+
 template <typename Element>
 Ciphertext<Element> CryptoContextImpl<Element>::EvalChebyshevFunction(std::function<double(double)> func,
                                                                       ConstCiphertext<Element> ciphertext, double a,
                                                                       double b, uint32_t degree) const {
     std::vector<double> coefficients = EvalChebyshevCoefficients(func, a, b, degree);
+    //std::vector<double> coefficients;// = EvalChebyshevCoefficients(func, a, b, degree);
     return EvalChebyshevSeries(ciphertext, coefficients, a, b);
 }
 
diff --git a/src/pke/lib/keyswitch/keyswitch-hybrid.cpp b/src/pke/lib/keyswitch/keyswitch-hybrid.cpp
index fb7cd35c..af58aa6e 100644
--- a/src/pke/lib/keyswitch/keyswitch-hybrid.cpp
+++ b/src/pke/lib/keyswitch/keyswitch-hybrid.cpp
@@ -382,6 +382,7 @@ std::shared_ptr<std::vector<DCRTPoly>> KeySwitchHYBRID::EvalKeySwitchPrecomputeC
 
     for (uint32_t part = 0; part < numPartQl; part++) {
         auto partCtClone = partsCt[part].Clone();
+
         partCtClone.SetFormat(Format::COEFFICIENT);
 
         uint32_t sizePartQl = partsCt[part].GetNumOfElements();
@@ -475,7 +476,7 @@ std::shared_ptr<std::vector<DCRTPoly>> KeySwitchHYBRID::EvalFastKeySwitchCoreExt
             cTilda1.SetElementAtIndex(i, cTilda1.GetElementAtIndex(i) + cji * aji);
         }
     }
-
+    
     return std::make_shared<std::vector<DCRTPoly>>(
         std::initializer_list<DCRTPoly>{std::move(cTilda0), std::move(cTilda1)});
 }
diff --git a/src/pke/lib/scheme/ckksrns/ckksrns-advancedshe.cpp b/src/pke/lib/scheme/ckksrns/ckksrns-advancedshe.cpp
index 9d0f2ff0..2172aa53 100644
--- a/src/pke/lib/scheme/ckksrns/ckksrns-advancedshe.cpp
+++ b/src/pke/lib/scheme/ckksrns/ckksrns-advancedshe.cpp
@@ -820,10 +820,16 @@ Ciphertext<DCRTPoly> AdvancedSHECKKSRNS::InnerEvalChebyshevPS(ConstCiphertext<DC
             qu = cc->EvalLinearWSumMutable(ctxs, weights);
             // the highest order coefficient will always be a power of two up to 2^{m-1} because q is "monic" but the Chebyshev rule adds a factor of 2
             // we don't need to increase the depth by multiplying the highest order coefficient, but instead checking and summing, since we work with m <= 4.
+
+
             Ciphertext<DCRTPoly> sum = T[k - 1]->Clone();
             for (uint32_t i = 0; i < log2(divqr->q.back()); i++) {
                 sum = cc->EvalAdd(sum, sum);
             }
+            /*
+            Ciphertext<DCRTPoly> sum = cc->EvalMult(T[k - 1], divqr->q.back());
+            cc->RescaleInPlace(sum);
+            */
             cc->EvalAddInPlace(qu, sum);
         }
         else {
@@ -839,7 +845,7 @@ Ciphertext<DCRTPoly> AdvancedSHECKKSRNS::InnerEvalChebyshevPS(ConstCiphertext<DC
         // The number of levels of qu is the same as the number of levels of T[k-1] or T[k-1] + 1.
         // No need to reduce it to T2[m-1] because it only reaches here when m = 2.
     }
-
+   
     Ciphertext<DCRTPoly> su;
 
     if (Degree(s2) > k) {
@@ -873,7 +879,7 @@ Ciphertext<DCRTPoly> AdvancedSHECKKSRNS::InnerEvalChebyshevPS(ConstCiphertext<DC
         // su = cc->LevelReduce(su, nullptr, su->GetElements()[0].GetNumOfElements() - Lm + 1) ;
         cc->LevelReduceInPlace(su, nullptr);
     }
-
+   
     Ciphertext<DCRTPoly> result;
 
     if (flag_c) {
diff --git a/src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp b/src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp
index 965453a2..ef185fdb 100644
--- a/src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp
+++ b/src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp
@@ -61,7 +61,7 @@ namespace lbcrypto {
 
 void FHECKKSRNS::EvalBootstrapSetup(const CryptoContextImpl<DCRTPoly>& cc, std::vector<uint32_t> levelBudget,
                                     std::vector<uint32_t> dim1, uint32_t numSlots, uint32_t correctionFactor,
-                                    bool precompute) {
+                                    bool precompute, int32_t modevallevels) {
     const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(cc.GetCryptoParameters());
 
     if (cryptoParams->GetKeySwitchTechnique() != HYBRID)
@@ -165,7 +165,7 @@ void FHECKKSRNS::EvalBootstrapSetup(const CryptoContextImpl<DCRTPoly>& cc, std::
         double scaleEnc  = pre / k;
         double scaleDec  = 1 / pre;
 
-        uint32_t approxModDepth = GetModDepthInternal(cryptoParams->GetSecretKeyDist());
+        uint32_t approxModDepth = modevallevels == -1 ? GetModDepthInternal(cryptoParams->GetSecretKeyDist()) : modevallevels;
         uint32_t depthBT        = approxModDepth + precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] +
                            precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET];
 
@@ -337,6 +337,1061 @@ void FHECKKSRNS::EvalBootstrapPrecompute(const CryptoContextImpl<DCRTPoly>& cc,
     }
 }
 
+Ciphertext<DCRTPoly> FHECKKSRNS::EvalBootstrapSetupOnly(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                            uint32_t precision) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ciphertext->GetCryptoParameters());
+
+    if (cryptoParams->GetKeySwitchTechnique() != HYBRID)
+        OPENFHE_THROW("CKKS Bootstrapping is only supported for the Hybrid key switching method.");
+#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTO || cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT)
+        OPENFHE_THROW("128-bit CKKS Bootstrapping is supported for FIXEDMANUAL and FIXEDAUTO methods only.");
+#endif
+    if (numIterations != 1 && numIterations != 2) {
+        OPENFHE_THROW("CKKS Iterative Bootstrapping is only supported for 1 or 2 iterations.");
+    }
+
+#ifdef BOOTSTRAPTIMING
+    TimeVar t;
+    double timeEncode(0.0);
+    double timeModReduce(0.0);
+    double timeDecode(0.0);
+#endif
+
+    auto cc        = ciphertext->GetCryptoContext();
+    uint32_t M     = cc->GetCyclotomicOrder();
+    uint32_t L0    = cryptoParams->GetElementParams()->GetParams().size();
+    auto initSizeQ = ciphertext->GetElements()[0].GetNumOfElements();
+
+    if (numIterations > 1) {
+        // Step 1: Get the input.
+        uint32_t powerOfTwoModulus = 1 << precision;
+
+        // Step 2: Scale up by powerOfTwoModulus, and extend the modulus to powerOfTwoModulus * q.
+        // Note that we extend the modulus implicitly without any code calls because the value always stays 0.
+        Ciphertext<DCRTPoly> ctScaledUp = ciphertext->Clone();
+        // We multiply by powerOfTwoModulus, and leave the last CRT value to be 0 (mod powerOfTwoModulus).
+        cc->GetScheme()->MultByIntegerInPlace(ctScaledUp, powerOfTwoModulus);
+        ctScaledUp->SetLevel(L0 - ctScaledUp->GetElements()[0].GetNumOfElements());
+
+        // Step 3: Bootstrap the initial ciphertext.
+        auto ctInitialBootstrap = cc->EvalBootstrap(ciphertext, numIterations - 1, precision);
+        cc->GetScheme()->ModReduceInternalInPlace(ctInitialBootstrap, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 4: Scale up by powerOfTwoModulus.
+        cc->GetScheme()->MultByIntegerInPlace(ctInitialBootstrap, powerOfTwoModulus);
+
+        // Step 5: Mod-down to powerOfTwoModulus * q
+        // We mod down, and leave the last CRT value to be 0 because it's divisible by powerOfTwoModulus.
+        auto ctBootstrappedScaledDown = ctInitialBootstrap->Clone();
+        auto bootstrappingSizeQ       = ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements();
+
+        // If we start with more towers, than we obtain from bootstrapping, return the original ciphertext.
+        if (bootstrappingSizeQ <= initSizeQ) {
+            return ciphertext->Clone();
+        }
+        for (auto& cv : ctBootstrappedScaledDown->GetElements()) {
+            cv.DropLastElements(bootstrappingSizeQ - initSizeQ);
+        }
+        ctBootstrappedScaledDown->SetLevel(L0 - ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements());
+
+        // Step 6 and 7: Calculate the bootstrapping error by subtracting the original ciphertext from the bootstrapped ciphertext. Mod down to q is done implicitly.
+        auto ctBootstrappingError = cc->EvalSub(ctBootstrappedScaledDown, ctScaledUp);
+
+        // Step 8: Bootstrap the error.
+        auto ctBootstrappedError = cc->EvalBootstrap(ctBootstrappingError, 1, 0);
+        cc->GetScheme()->ModReduceInternalInPlace(ctBootstrappedError, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 9: Subtract the bootstrapped error from the initial bootstrap to get even lower error.
+        auto finalCiphertext = cc->EvalSub(ctInitialBootstrap, ctBootstrappedError);
+
+        // Step 10: Scale back down by powerOfTwoModulus to get the original message.
+        cc->EvalMultInPlace(finalCiphertext, static_cast<double>(1) / powerOfTwoModulus);
+        return finalCiphertext;
+    }
+
+    uint32_t slots = ciphertext->GetSlots();
+
+    auto pair = m_bootPrecomMap.find(slots);
+    if (pair == m_bootPrecomMap.end()) {
+        std::string errorMsg(std::string("Precomputations for ") + std::to_string(slots) +
+                             std::string(" slots were not generated") +
+                             std::string(" Need to call EvalBootstrapSetup and then EvalBootstrapKeyGen to proceed"));
+        OPENFHE_THROW(errorMsg);
+    }
+    const std::shared_ptr<CKKSBootstrapPrecom> precom = pair->second;
+    size_t N                                          = cc->GetRingDimension();
+
+    auto elementParamsRaised = *(cryptoParams->GetElementParams());
+
+    // For FLEXIBLEAUTOEXT we raised ciphertext does not include extra modulus
+    // as it is multiplied by auxiliary plaintext
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT) {
+        elementParamsRaised.PopLastParam();
+    }
+
+    auto paramsQ = elementParamsRaised.GetParams();
+    usint sizeQ  = paramsQ.size();
+
+    std::vector<NativeInteger> moduli(sizeQ);
+    std::vector<NativeInteger> roots(sizeQ);
+    for (size_t i = 0; i < sizeQ; i++) {
+        moduli[i] = paramsQ[i]->GetModulus();
+        roots[i]  = paramsQ[i]->GetRootOfUnity();
+    }
+    auto elementParamsRaisedPtr = std::make_shared<ILDCRTParams<DCRTPoly::Integer>>(M, moduli, roots);
+
+    NativeInteger q = elementParamsRaisedPtr->GetParams()[0]->GetModulus().ConvertToInt();
+    double qDouble  = q.ConvertToDouble();
+
+    const auto p = cryptoParams->GetPlaintextModulus();
+    double powP  = pow(2, p);
+
+    int32_t deg = std::round(std::log2(qDouble / powP));
+#if NATIVEINT != 128
+    if (deg > static_cast<int32_t>(m_correctionFactor)) {
+        OPENFHE_THROW("Degree [" + std::to_string(deg) + "] must be less than or equal to the correction factor [" +
+                      std::to_string(m_correctionFactor) + "].");
+    }
+#endif
+    uint32_t correction = m_correctionFactor - deg;
+    double post         = std::pow(2, static_cast<double>(deg));
+
+    double pre      = 1. / post;
+    uint64_t scalar = std::llround(post);
+
+    //------------------------------------------------------------------------------
+    // RAISING THE MODULUS
+    //------------------------------------------------------------------------------
+
+    // In FLEXIBLEAUTO, raising the ciphertext to a larger number
+    // of towers is a bit more complex, because we need to adjust
+    // it's scaling factor to the one that corresponds to the level
+    // it's being raised to.
+    // Increasing the modulus
+
+    Ciphertext<DCRTPoly> raised = ciphertext->Clone();
+    auto algo                   = cc->GetScheme();
+    algo->ModReduceInternalInPlace(raised, raised->GetNoiseScaleDeg() - 1);
+
+    AdjustCiphertext(raised, correction);
+    auto ctxtDCRT = raised->GetElements();
+
+    // We only use the level 0 ciphertext here. All other towers are automatically ignored to make
+    // CKKS bootstrapping faster.
+    for (size_t i = 0; i < ctxtDCRT.size(); i++) {
+        DCRTPoly temp(elementParamsRaisedPtr, COEFFICIENT);
+        ctxtDCRT[i].SetFormat(COEFFICIENT);
+        temp = ctxtDCRT[i].GetElementAtIndex(0);
+        temp.SetFormat(EVALUATION);
+        ctxtDCRT[i] = temp;
+    }
+
+    raised->SetElements(ctxtDCRT);
+    raised->SetLevel(L0 - ctxtDCRT[0].GetNumOfElements());
+
+#ifdef BOOTSTRAPTIMING
+    std::cerr << "\nNumber of levels at the beginning of bootstrapping: "
+              << raised->GetElements()[0].GetNumOfElements() - 1 << std::endl;
+#endif
+
+    //------------------------------------------------------------------------------
+    // SETTING PARAMETERS FOR APPROXIMATE MODULAR REDUCTION
+    //------------------------------------------------------------------------------
+
+    // Coefficients of the Chebyshev series interpolating 1/(2 Pi) Sin(2 Pi K x)
+    std::vector<double> coefficients;
+    double k = 0;
+
+    if (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY) {
+        coefficients = g_coefficientsSparse;
+        // k = K_SPARSE;
+        k = 1.0;  // do not divide by k as we already did it during precomputation
+    }
+    else {
+        coefficients = g_coefficientsUniform;
+        k            = K_UNIFORM;
+    }
+
+    double constantEvalMult = pre * (1.0 / (k * N));
+
+    cc->EvalMultInPlace(raised, constantEvalMult);
+
+    // no linear transformations are needed for Chebyshev series as the range has been normalized to [-1,1]
+    double coeffLowerBound = -1;
+    double coeffUpperBound = 1;
+
+    Ciphertext<DCRTPoly> ctxtDec;
+
+    bool isLTBootstrap = (precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1) &&
+                         (precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1);
+    if (slots == M / 4) {
+        //------------------------------------------------------------------------------
+        // FULLY PACKED CASE
+        //------------------------------------------------------------------------------
+
+#ifdef BOOTSTRAPTIMING
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running CoeffToSlot
+        //------------------------------------------------------------------------------
+
+        // need to call internal modular reduction so it also works for FLEXIBLEAUTO
+        algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
+
+        return raised;
+        // only one linear transform is needed as the other one can be derived
+        auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
+                                         EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
+
+        auto evalKeyMap = cc->GetEvalAutomorphismKeyMap(ctxtEnc->GetKeyTag());
+        auto conj       = Conjugate(ctxtEnc, evalKeyMap);
+        auto ctxtEncI   = cc->EvalSub(ctxtEnc, conj);
+        cc->EvalAddInPlace(ctxtEnc, conj);
+        algo->MultByMonomialInPlace(ctxtEncI, 3 * M / 4);
+
+        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+            while (ctxtEnc->GetNoiseScaleDeg() > 1) {
+                cc->ModReduceInPlace(ctxtEnc);
+                cc->ModReduceInPlace(ctxtEncI);
+            }
+        }
+        else {
+            if (ctxtEnc->GetNoiseScaleDeg() == 2) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+                algo->ModReduceInternalInPlace(ctxtEncI, BASE_NUM_LEVELS_TO_DROP);
+            }
+        }
+
+        //------------------------------------------------------------------------------
+        // Running Approximate Mod Reduction
+        //------------------------------------------------------------------------------
+
+        // Evaluate Chebyshev series for the sine wave
+        ctxtEnc  = cc->EvalChebyshevSeries(ctxtEnc, coefficients, coeffLowerBound, coeffUpperBound);
+        ctxtEncI = cc->EvalChebyshevSeries(ctxtEncI, coefficients, coeffLowerBound, coeffUpperBound);
+
+        // Double-angle iterations
+        if ((cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY) ||
+            (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY)) {
+            if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+                algo->ModReduceInternalInPlace(ctxtEncI, BASE_NUM_LEVELS_TO_DROP);
+            }
+            uint32_t numIter;
+            if (cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY)
+                numIter = R_UNIFORM;
+            else
+                numIter = R_SPARSE;
+            ApplyDoubleAngleIterations(ctxtEnc, numIter);
+            ApplyDoubleAngleIterations(ctxtEncI, numIter);
+        }
+
+        algo->MultByMonomialInPlace(ctxtEncI, M / 4);
+        cc->EvalAddInPlace(ctxtEnc, ctxtEncI);
+
+        // scale the message back up after Chebyshev interpolation
+        algo->MultByIntegerInPlace(ctxtEnc, scalar);
+
+#ifdef BOOTSTRAPTIMING
+        timeModReduce = TOC(t);
+
+        std::cerr << "Approximate modular reduction time: " << timeModReduce / 1000.0 << " s" << std::endl;
+
+        // Running SlotToCoeff
+
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running SlotToCoeff
+        //------------------------------------------------------------------------------
+
+        // In the case of FLEXIBLEAUTO, we need one extra tower
+        // TODO: See if we can remove the extra level in FLEXIBLEAUTO
+        if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+            algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+        }
+
+        // Only one linear transform is needed
+        ctxtDec = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0Pre, ctxtEnc) :
+                                    EvalSlotsToCoeffs(precom->m_U0PreFFT, ctxtEnc);
+    }
+    else {
+        //------------------------------------------------------------------------------
+        // SPARSELY PACKED CASE
+        //------------------------------------------------------------------------------
+
+        //------------------------------------------------------------------------------
+        // Running PartialSum
+        //------------------------------------------------------------------------------
+
+        for (uint32_t j = 1; j < N / (2 * slots); j <<= 1) {
+            auto temp = cc->EvalRotate(raised, j * slots);
+            cc->EvalAddInPlace(raised, temp);
+        }
+
+#ifdef BOOTSTRAPTIMING
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running CoeffsToSlots
+        //------------------------------------------------------------------------------
+
+        algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
+
+        return raised;
+
+        auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
+                                         EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
+
+        auto evalKeyMap = cc->GetEvalAutomorphismKeyMap(ctxtEnc->GetKeyTag());
+        auto conj       = Conjugate(ctxtEnc, evalKeyMap);
+        cc->EvalAddInPlace(ctxtEnc, conj);
+
+        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+            while (ctxtEnc->GetNoiseScaleDeg() > 1) {
+                cc->ModReduceInPlace(ctxtEnc);
+            }
+        }
+        else {
+            if (ctxtEnc->GetNoiseScaleDeg() == 2) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+            }
+        }
+
+#ifdef BOOTSTRAPTIMING
+        timeEncode = TOC(t);
+
+        std::cerr << "\nEncoding time: " << timeEncode / 1000.0 << " s" << std::endl;
+
+        // Running Approximate Mod Reduction
+
+        TIC(t);
+#endif
+
+        return ctxtEnc;
+        //------------------------------------------------------------------------------
+        // Running Approximate Mod Reduction
+        //------------------------------------------------------------------------------
+
+        // Evaluate Chebyshev series for the sine wave
+        ctxtEnc = cc->EvalChebyshevSeries(ctxtEnc, coefficients, coeffLowerBound, coeffUpperBound);
+
+        // Double-angle iterations
+        if ((cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY) ||
+            (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY)) {
+            if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+            }
+            uint32_t numIter;
+            if (cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY)
+                numIter = R_UNIFORM;
+            else
+                numIter = R_SPARSE;
+            ApplyDoubleAngleIterations(ctxtEnc, numIter);
+        }
+
+        // scale the message back up after Chebyshev interpolation
+        algo->MultByIntegerInPlace(ctxtEnc, scalar);
+
+#ifdef BOOTSTRAPTIMING
+        timeModReduce = TOC(t);
+
+        std::cerr << "Approximate modular reduction time: " << timeModReduce / 1000.0 << " s" << std::endl;
+
+        // Running SlotToCoeff
+
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running SlotsToCoeffs
+        //------------------------------------------------------------------------------
+
+        // In the case of FLEXIBLEAUTO, we need one extra tower
+        // TODO: See if we can remove the extra level in FLEXIBLEAUTO
+        if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+            algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+        }
+
+        // linear transform for decoding
+        ctxtDec = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0Pre, ctxtEnc) :
+                                    EvalSlotsToCoeffs(precom->m_U0PreFFT, ctxtEnc);
+
+        cc->EvalAddInPlace(ctxtDec, cc->EvalRotate(ctxtDec, slots));
+    }
+
+#if NATIVEINT != 128
+    // 64-bit only: scale back the message to its original scale.
+    uint64_t corFactor = (uint64_t)1 << std::llround(correction);
+    algo->MultByIntegerInPlace(ctxtDec, corFactor);
+#endif
+
+#ifdef BOOTSTRAPTIMING
+    timeDecode = TOC(t);
+
+    std::cout << "Decoding time: " << timeDecode / 1000.0 << " s" << std::endl;
+#endif
+
+    auto bootstrappingNumTowers = ctxtDec->GetElements()[0].GetNumOfElements();
+
+    // If we start with more towers, than we obtain from bootstrapping, return the original ciphertext.
+    if (bootstrappingNumTowers <= initSizeQ) {
+        return ciphertext->Clone();
+    }
+
+    return ctxtDec;
+}
+
+std::pair<Ciphertext<DCRTPoly>, Ciphertext<DCRTPoly>>  FHECKKSRNS::EvalBootstrapDensePartial(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                               uint32_t precision) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ciphertext->GetCryptoParameters());
+
+    if (cryptoParams->GetKeySwitchTechnique() != HYBRID)
+        OPENFHE_THROW("CKKS Bootstrapping is only supported for the Hybrid key switching method.");
+#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTO || cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT)
+        OPENFHE_THROW("128-bit CKKS Bootstrapping is supported for FIXEDMANUAL and FIXEDAUTO methods only.");
+#endif
+    if (numIterations != 1 && numIterations != 2) {
+        OPENFHE_THROW("CKKS Iterative Bootstrapping is only supported for 1 or 2 iterations.");
+    }
+
+#ifdef BOOTSTRAPTIMING
+    TimeVar t;
+    double timeEncode(0.0);
+    double timeModReduce(0.0);
+    double timeDecode(0.0);
+#endif
+
+    auto cc        = ciphertext->GetCryptoContext();
+    uint32_t M     = cc->GetCyclotomicOrder();
+    uint32_t L0    = cryptoParams->GetElementParams()->GetParams().size();
+    auto initSizeQ = ciphertext->GetElements()[0].GetNumOfElements();
+
+    if (numIterations > 1) {
+        // Step 1: Get the input.
+        uint32_t powerOfTwoModulus = 1 << precision;
+
+        // Step 2: Scale up by powerOfTwoModulus, and extend the modulus to powerOfTwoModulus * q.
+        // Note that we extend the modulus implicitly without any code calls because the value always stays 0.
+        Ciphertext<DCRTPoly> ctScaledUp = ciphertext->Clone();
+        // We multiply by powerOfTwoModulus, and leave the last CRT value to be 0 (mod powerOfTwoModulus).
+        cc->GetScheme()->MultByIntegerInPlace(ctScaledUp, powerOfTwoModulus);
+        ctScaledUp->SetLevel(L0 - ctScaledUp->GetElements()[0].GetNumOfElements());
+
+        // Step 3: Bootstrap the initial ciphertext.
+        auto ctInitialBootstrap = cc->EvalBootstrap(ciphertext, numIterations - 1, precision);
+        cc->GetScheme()->ModReduceInternalInPlace(ctInitialBootstrap, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 4: Scale up by powerOfTwoModulus.
+        cc->GetScheme()->MultByIntegerInPlace(ctInitialBootstrap, powerOfTwoModulus);
+
+        // Step 5: Mod-down to powerOfTwoModulus * q
+        // We mod down, and leave the last CRT value to be 0 because it's divisible by powerOfTwoModulus.
+        auto ctBootstrappedScaledDown = ctInitialBootstrap->Clone();
+        auto bootstrappingSizeQ       = ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements();
+
+        // If we start with more towers, than we obtain from bootstrapping, return the original ciphertext.
+        if (bootstrappingSizeQ <= initSizeQ) {
+            //return ciphertext->Clone();
+        }
+        for (auto& cv : ctBootstrappedScaledDown->GetElements()) {
+            cv.DropLastElements(bootstrappingSizeQ - initSizeQ);
+        }
+        ctBootstrappedScaledDown->SetLevel(L0 - ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements());
+
+        // Step 6 and 7: Calculate the bootstrapping error by subtracting the original ciphertext from the bootstrapped ciphertext. Mod down to q is done implicitly.
+        auto ctBootstrappingError = cc->EvalSub(ctBootstrappedScaledDown, ctScaledUp);
+
+        // Step 8: Bootstrap the error.
+        auto ctBootstrappedError = cc->EvalBootstrap(ctBootstrappingError, 1, 0);
+        cc->GetScheme()->ModReduceInternalInPlace(ctBootstrappedError, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 9: Subtract the bootstrapped error from the initial bootstrap to get even lower error.
+        auto finalCiphertext = cc->EvalSub(ctInitialBootstrap, ctBootstrappedError);
+
+        // Step 10: Scale back down by powerOfTwoModulus to get the original message.
+        cc->EvalMultInPlace(finalCiphertext, static_cast<double>(1) / powerOfTwoModulus);
+        //return finalCiphertext;
+    }
+
+    uint32_t slots = ciphertext->GetSlots();
+
+    auto pair = m_bootPrecomMap.find(slots);
+    if (pair == m_bootPrecomMap.end()) {
+        std::string errorMsg(std::string("Precomputations for ") + std::to_string(slots) +
+                             std::string(" slots were not generated") +
+                             std::string(" Need to call EvalBootstrapSetup and then EvalBootstrapKeyGen to proceed"));
+        OPENFHE_THROW(errorMsg);
+    }
+    const std::shared_ptr<CKKSBootstrapPrecom> precom = pair->second;
+    size_t N                                          = cc->GetRingDimension();
+
+    auto elementParamsRaised = *(cryptoParams->GetElementParams());
+
+    // For FLEXIBLEAUTOEXT we raised ciphertext does not include extra modulus
+    // as it is multiplied by auxiliary plaintext
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT) {
+        elementParamsRaised.PopLastParam();
+    }
+
+    auto paramsQ = elementParamsRaised.GetParams();
+    usint sizeQ  = paramsQ.size();
+
+    std::vector<NativeInteger> moduli(sizeQ);
+    std::vector<NativeInteger> roots(sizeQ);
+    for (size_t i = 0; i < sizeQ; i++) {
+        moduli[i] = paramsQ[i]->GetModulus();
+        roots[i]  = paramsQ[i]->GetRootOfUnity();
+    }
+    auto elementParamsRaisedPtr = std::make_shared<ILDCRTParams<DCRTPoly::Integer>>(M, moduli, roots);
+
+    NativeInteger q = elementParamsRaisedPtr->GetParams()[0]->GetModulus().ConvertToInt();
+    double qDouble  = q.ConvertToDouble();
+
+    const auto p = cryptoParams->GetPlaintextModulus();
+    double powP  = pow(2, p);
+
+    int32_t deg = std::round(std::log2(qDouble / powP));
+#if NATIVEINT != 128
+    if (deg > static_cast<int32_t>(m_correctionFactor)) {
+        OPENFHE_THROW("Degree [" + std::to_string(deg) + "] must be less than or equal to the correction factor [" +
+                      std::to_string(m_correctionFactor) + "].");
+    }
+#endif
+    uint32_t correction = m_correctionFactor - deg;
+    double post         = std::pow(2, static_cast<double>(deg));
+
+    double pre      = 1. / post;
+    //uint64_t scalar = std::llround(post);
+
+    //------------------------------------------------------------------------------
+    // RAISING THE MODULUS
+    //------------------------------------------------------------------------------
+
+    // In FLEXIBLEAUTO, raising the ciphertext to a larger number
+    // of towers is a bit more complex, because we need to adjust
+    // it's scaling factor to the one that corresponds to the level
+    // it's being raised to.
+    // Increasing the modulus
+
+    Ciphertext<DCRTPoly> raised = ciphertext->Clone();
+    auto algo                   = cc->GetScheme();
+    algo->ModReduceInternalInPlace(raised, raised->GetNoiseScaleDeg() - 1);
+
+    AdjustCiphertext(raised, correction);
+    auto ctxtDCRT = raised->GetElements();
+
+    // We only use the level 0 ciphertext here. All other towers are automatically ignored to make
+    // CKKS bootstrapping faster.
+    for (size_t i = 0; i < ctxtDCRT.size(); i++) {
+        DCRTPoly temp(elementParamsRaisedPtr, COEFFICIENT);
+        ctxtDCRT[i].SetFormat(COEFFICIENT);
+        temp = ctxtDCRT[i].GetElementAtIndex(0);
+        temp.SetFormat(EVALUATION);
+        ctxtDCRT[i] = temp;
+    }
+
+    raised->SetElements(ctxtDCRT);
+    raised->SetLevel(L0 - ctxtDCRT[0].GetNumOfElements());
+
+#ifdef BOOTSTRAPTIMING
+    std::cerr << "\nNumber of levels at the beginning of bootstrapping: "
+              << raised->GetElements()[0].GetNumOfElements() - 1 << std::endl;
+#endif
+
+    //------------------------------------------------------------------------------
+    // SETTING PARAMETERS FOR APPROXIMATE MODULAR REDUCTION
+    //------------------------------------------------------------------------------
+
+    // Coefficients of the Chebyshev series interpolating 1/(2 Pi) Sin(2 Pi K x)
+    std::vector<double> coefficients;
+    double k = 0;
+
+    if (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY) {
+        coefficients = g_coefficientsSparse;
+        // k = K_SPARSE;
+        k = 1.0;  // do not divide by k as we already did it during precomputation
+    }
+    else {
+        coefficients = g_coefficientsUniform;
+        k            = K_UNIFORM;
+    }
+
+    double constantEvalMult = pre * (1.0 / (k * N));
+
+    cc->EvalMultInPlace(raised, constantEvalMult);
+
+    // no linear transformations are needed for Chebyshev series as the range has been normalized to [-1,1]
+  //  double coeffLowerBound = -1;
+  //  double coeffUpperBound = 1;
+
+    Ciphertext<DCRTPoly> ctxtDec;
+
+    bool isLTBootstrap = (precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1) &&
+                         (precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1);
+    if (slots == M / 4) {
+        //------------------------------------------------------------------------------
+        // FULLY PACKED CASE
+        //------------------------------------------------------------------------------
+
+#ifdef BOOTSTRAPTIMING
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running CoeffToSlot
+        //------------------------------------------------------------------------------
+
+        // need to call internal modular reduction so it also works for FLEXIBLEAUTO
+        algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
+
+        // only one linear transform is needed as the other one can be derived
+        auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
+                                         EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
+
+
+        return {ctxtEnc, ctxtEnc};
+
+        auto evalKeyMap = cc->GetEvalAutomorphismKeyMap(ctxtEnc->GetKeyTag());
+        auto conj       = Conjugate(ctxtEnc, evalKeyMap);
+        auto ctxtEncI   = cc->EvalSub(ctxtEnc, conj);
+        cc->EvalAddInPlace(ctxtEnc, conj);
+        algo->MultByMonomialInPlace(ctxtEncI, 3 * M / 4);
+
+        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+            while (ctxtEnc->GetNoiseScaleDeg() > 1) {
+                cc->ModReduceInPlace(ctxtEnc);
+                cc->ModReduceInPlace(ctxtEncI);
+            }
+        }
+        else {
+            if (ctxtEnc->GetNoiseScaleDeg() == 2) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+                algo->ModReduceInternalInPlace(ctxtEncI, BASE_NUM_LEVELS_TO_DROP);
+            }
+        }
+
+
+    }
+    return {
+        nullptr, nullptr };
+}
+
+Ciphertext<DCRTPoly> FHECKKSRNS::EvalBootstrapNoStC(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
+                                               uint32_t precision) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ciphertext->GetCryptoParameters());
+
+    if (cryptoParams->GetKeySwitchTechnique() != HYBRID)
+        OPENFHE_THROW("CKKS Bootstrapping is only supported for the Hybrid key switching method.");
+#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTO || cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT)
+        OPENFHE_THROW("128-bit CKKS Bootstrapping is supported for FIXEDMANUAL and FIXEDAUTO methods only.");
+#endif
+    if (numIterations != 1 && numIterations != 2) {
+        OPENFHE_THROW("CKKS Iterative Bootstrapping is only supported for 1 or 2 iterations.");
+    }
+
+#ifdef BOOTSTRAPTIMING
+    TimeVar t;
+    double timeEncode(0.0);
+    double timeModReduce(0.0);
+    double timeDecode(0.0);
+#endif
+
+    auto cc        = ciphertext->GetCryptoContext();
+    uint32_t M     = cc->GetCyclotomicOrder();
+    uint32_t L0    = cryptoParams->GetElementParams()->GetParams().size();
+    auto initSizeQ = ciphertext->GetElements()[0].GetNumOfElements();
+
+    if (numIterations > 1) {
+        // Step 1: Get the input.
+        uint32_t powerOfTwoModulus = 1 << precision;
+
+        // Step 2: Scale up by powerOfTwoModulus, and extend the modulus to powerOfTwoModulus * q.
+        // Note that we extend the modulus implicitly without any code calls because the value always stays 0.
+        Ciphertext<DCRTPoly> ctScaledUp = ciphertext->Clone();
+        // We multiply by powerOfTwoModulus, and leave the last CRT value to be 0 (mod powerOfTwoModulus).
+        cc->GetScheme()->MultByIntegerInPlace(ctScaledUp, powerOfTwoModulus);
+        ctScaledUp->SetLevel(L0 - ctScaledUp->GetElements()[0].GetNumOfElements());
+
+        // Step 3: Bootstrap the initial ciphertext.
+        auto ctInitialBootstrap = cc->EvalBootstrap(ciphertext, numIterations - 1, precision);
+        cc->GetScheme()->ModReduceInternalInPlace(ctInitialBootstrap, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 4: Scale up by powerOfTwoModulus.
+        cc->GetScheme()->MultByIntegerInPlace(ctInitialBootstrap, powerOfTwoModulus);
+
+        // Step 5: Mod-down to powerOfTwoModulus * q
+        // We mod down, and leave the last CRT value to be 0 because it's divisible by powerOfTwoModulus.
+        auto ctBootstrappedScaledDown = ctInitialBootstrap->Clone();
+        auto bootstrappingSizeQ       = ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements();
+
+        // If we start with more towers, than we obtain from bootstrapping, return the original ciphertext.
+        if (bootstrappingSizeQ <= initSizeQ) {
+            return ciphertext->Clone();
+        }
+        for (auto& cv : ctBootstrappedScaledDown->GetElements()) {
+            cv.DropLastElements(bootstrappingSizeQ - initSizeQ);
+        }
+        ctBootstrappedScaledDown->SetLevel(L0 - ctBootstrappedScaledDown->GetElements()[0].GetNumOfElements());
+
+        // Step 6 and 7: Calculate the bootstrapping error by subtracting the original ciphertext from the bootstrapped ciphertext. Mod down to q is done implicitly.
+        auto ctBootstrappingError = cc->EvalSub(ctBootstrappedScaledDown, ctScaledUp);
+
+        // Step 8: Bootstrap the error.
+        auto ctBootstrappedError = cc->EvalBootstrap(ctBootstrappingError, 1, 0);
+        cc->GetScheme()->ModReduceInternalInPlace(ctBootstrappedError, BASE_NUM_LEVELS_TO_DROP);
+
+        // Step 9: Subtract the bootstrapped error from the initial bootstrap to get even lower error.
+        auto finalCiphertext = cc->EvalSub(ctInitialBootstrap, ctBootstrappedError);
+
+        // Step 10: Scale back down by powerOfTwoModulus to get the original message.
+        cc->EvalMultInPlace(finalCiphertext, static_cast<double>(1) / powerOfTwoModulus);
+        return finalCiphertext;
+    }
+
+    uint32_t slots = ciphertext->GetSlots();
+
+    auto pair = m_bootPrecomMap.find(slots);
+    if (pair == m_bootPrecomMap.end()) {
+        std::string errorMsg(std::string("Precomputations for ") + std::to_string(slots) +
+                             std::string(" slots were not generated") +
+                             std::string(" Need to call EvalBootstrapSetup and then EvalBootstrapKeyGen to proceed"));
+        OPENFHE_THROW(errorMsg);
+    }
+    const std::shared_ptr<CKKSBootstrapPrecom> precom = pair->second;
+    size_t N                                          = cc->GetRingDimension();
+
+    auto elementParamsRaised = *(cryptoParams->GetElementParams());
+
+    // For FLEXIBLEAUTOEXT we raised ciphertext does not include extra modulus
+    // as it is multiplied by auxiliary plaintext
+    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT) {
+        elementParamsRaised.PopLastParam();
+    }
+
+    auto paramsQ = elementParamsRaised.GetParams();
+    usint sizeQ  = paramsQ.size();
+
+    std::vector<NativeInteger> moduli(sizeQ);
+    std::vector<NativeInteger> roots(sizeQ);
+    for (size_t i = 0; i < sizeQ; i++) {
+        moduli[i] = paramsQ[i]->GetModulus();
+        roots[i]  = paramsQ[i]->GetRootOfUnity();
+    }
+    auto elementParamsRaisedPtr = std::make_shared<ILDCRTParams<DCRTPoly::Integer>>(M, moduli, roots);
+
+    NativeInteger q = elementParamsRaisedPtr->GetParams()[0]->GetModulus().ConvertToInt();
+    double qDouble  = q.ConvertToDouble();
+
+    const auto p = cryptoParams->GetPlaintextModulus();
+    double powP  = pow(2, p);
+
+    int32_t deg = std::round(std::log2(qDouble / powP));
+#if NATIVEINT != 128
+    if (deg > static_cast<int32_t>(m_correctionFactor)) {
+        OPENFHE_THROW("Degree [" + std::to_string(deg) + "] must be less than or equal to the correction factor [" +
+                      std::to_string(m_correctionFactor) + "].");
+    }
+#endif
+    uint32_t correction = m_correctionFactor - deg;
+    double post         = std::pow(2, static_cast<double>(deg));
+
+    double pre      = 1. / post;
+    uint64_t scalar = std::llround(post);
+
+    //------------------------------------------------------------------------------
+    // RAISING THE MODULUS
+    //------------------------------------------------------------------------------
+
+    // In FLEXIBLEAUTO, raising the ciphertext to a larger number
+    // of towers is a bit more complex, because we need to adjust
+    // it's scaling factor to the one that corresponds to the level
+    // it's being raised to.
+    // Increasing the modulus
+
+    Ciphertext<DCRTPoly> raised = ciphertext->Clone();
+    auto algo                   = cc->GetScheme();
+    algo->ModReduceInternalInPlace(raised, raised->GetNoiseScaleDeg() - 1);
+
+    AdjustCiphertext(raised, correction);
+    auto ctxtDCRT = raised->GetElements();
+
+    // We only use the level 0 ciphertext here. All other towers are automatically ignored to make
+    // CKKS bootstrapping faster.
+    for (size_t i = 0; i < ctxtDCRT.size(); i++) {
+        DCRTPoly temp(elementParamsRaisedPtr, COEFFICIENT);
+        ctxtDCRT[i].SetFormat(COEFFICIENT);
+        temp = ctxtDCRT[i].GetElementAtIndex(0);
+        temp.SetFormat(EVALUATION);
+        ctxtDCRT[i] = temp;
+    }
+
+    raised->SetElements(ctxtDCRT);
+    raised->SetLevel(L0 - ctxtDCRT[0].GetNumOfElements());
+
+#ifdef BOOTSTRAPTIMING
+    std::cerr << "\nNumber of levels at the beginning of bootstrapping: "
+              << raised->GetElements()[0].GetNumOfElements() - 1 << std::endl;
+#endif
+
+    //------------------------------------------------------------------------------
+    // SETTING PARAMETERS FOR APPROXIMATE MODULAR REDUCTION
+    //------------------------------------------------------------------------------
+
+    // Coefficients of the Chebyshev series interpolating 1/(2 Pi) Sin(2 Pi K x)
+    std::vector<double> coefficients;
+    double k = 0;
+
+    if (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY) {
+        coefficients = g_coefficientsSparse;
+        // k = K_SPARSE;
+        k = 1.0;  // do not divide by k as we already did it during precomputation
+    }
+    else {
+        coefficients = g_coefficientsUniform;
+        k            = K_UNIFORM;
+    }
+
+    double constantEvalMult = pre * (1.0 / (k * N));
+
+    cc->EvalMultInPlace(raised, constantEvalMult);
+
+    // no linear transformations are needed for Chebyshev series as the range has been normalized to [-1,1]
+    double coeffLowerBound = -1;
+    double coeffUpperBound = 1;
+
+    Ciphertext<DCRTPoly> ctxtDec;
+
+    bool isLTBootstrap = (precom->m_paramsEnc[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1) &&
+                         (precom->m_paramsDec[CKKS_BOOT_PARAMS::LEVEL_BUDGET] == 1);
+    if (slots == M / 4) {
+        //------------------------------------------------------------------------------
+        // FULLY PACKED CASE
+        //------------------------------------------------------------------------------
+
+#ifdef BOOTSTRAPTIMING
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running CoeffToSlot
+        //------------------------------------------------------------------------------
+
+        // need to call internal modular reduction so it also works for FLEXIBLEAUTO
+        algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
+
+        // only one linear transform is needed as the other one can be derived
+        auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
+                                         EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
+
+        auto evalKeyMap = cc->GetEvalAutomorphismKeyMap(ctxtEnc->GetKeyTag());
+        auto conj       = Conjugate(ctxtEnc, evalKeyMap);
+        auto ctxtEncI   = cc->EvalSub(ctxtEnc, conj);
+        cc->EvalAddInPlace(ctxtEnc, conj);
+        algo->MultByMonomialInPlace(ctxtEncI, 3 * M / 4);
+
+        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+            while (ctxtEnc->GetNoiseScaleDeg() > 1) {
+                cc->ModReduceInPlace(ctxtEnc);
+                cc->ModReduceInPlace(ctxtEncI);
+            }
+        }
+        else {
+            if (ctxtEnc->GetNoiseScaleDeg() == 2) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+                algo->ModReduceInternalInPlace(ctxtEncI, BASE_NUM_LEVELS_TO_DROP);
+            }
+        }
+
+        //------------------------------------------------------------------------------
+        // Running Approximate Mod Reduction
+        //------------------------------------------------------------------------------
+
+        // Evaluate Chebyshev series for the sine wave
+        ctxtEnc  = cc->EvalChebyshevSeries(ctxtEnc, coefficients, coeffLowerBound, coeffUpperBound);
+        ctxtEncI = cc->EvalChebyshevSeries(ctxtEncI, coefficients, coeffLowerBound, coeffUpperBound);
+
+        // Double-angle iterations
+        if ((cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY) ||
+            (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY)) {
+            if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+                algo->ModReduceInternalInPlace(ctxtEncI, BASE_NUM_LEVELS_TO_DROP);
+            }
+            uint32_t numIter;
+            if (cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY)
+                numIter = R_UNIFORM;
+            else
+                numIter = R_SPARSE;
+            ApplyDoubleAngleIterations(ctxtEnc, numIter);
+            ApplyDoubleAngleIterations(ctxtEncI, numIter);
+        }
+
+        algo->MultByMonomialInPlace(ctxtEncI, M / 4);
+        cc->EvalAddInPlace(ctxtEnc, ctxtEncI);
+
+        // scale the message back up after Chebyshev interpolation
+        algo->MultByIntegerInPlace(ctxtEnc, scalar);
+
+#ifdef BOOTSTRAPTIMING
+        timeModReduce = TOC(t);
+
+        std::cerr << "Approximate modular reduction time: " << timeModReduce / 1000.0 << " s" << std::endl;
+
+        // Running SlotToCoeff
+
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running SlotToCoeff
+        //------------------------------------------------------------------------------
+
+        // In the case of FLEXIBLEAUTO, we need one extra tower
+        // TODO: See if we can remove the extra level in FLEXIBLEAUTO
+        if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+            algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+        }
+
+        return ctxtEnc;
+        // Only one linear transform is needed
+        ctxtDec = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0Pre, ctxtEnc) :
+                                    EvalSlotsToCoeffs(precom->m_U0PreFFT, ctxtEnc);
+    }
+    else {
+        //------------------------------------------------------------------------------
+        // SPARSELY PACKED CASE
+        //------------------------------------------------------------------------------
+
+        //------------------------------------------------------------------------------
+        // Running PartialSum
+        //------------------------------------------------------------------------------
+
+        for (uint32_t j = 1; j < N / (2 * slots); j <<= 1) {
+            auto temp = cc->EvalRotate(raised, j * slots);
+            cc->EvalAddInPlace(raised, temp);
+        }
+
+#ifdef BOOTSTRAPTIMING
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running CoeffsToSlots
+        //------------------------------------------------------------------------------
+
+        algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
+
+
+        auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
+                                         EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
+
+        auto evalKeyMap = cc->GetEvalAutomorphismKeyMap(ctxtEnc->GetKeyTag());
+        auto conj       = Conjugate(ctxtEnc, evalKeyMap);
+        cc->EvalAddInPlace(ctxtEnc, conj);
+
+        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+            while (ctxtEnc->GetNoiseScaleDeg() > 1) {
+                cc->ModReduceInPlace(ctxtEnc);
+            }
+        }
+        else {
+            if (ctxtEnc->GetNoiseScaleDeg() == 2) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+            }
+        }
+
+#ifdef BOOTSTRAPTIMING
+        timeEncode = TOC(t);
+
+        std::cerr << "\nEncoding time: " << timeEncode / 1000.0 << " s" << std::endl;
+
+        // Running Approximate Mod Reduction
+
+        TIC(t);
+#endif
+        //------------------------------------------------------------------------------
+        // Running Approximate Mod Reduction
+        //------------------------------------------------------------------------------
+
+        // Evaluate Chebyshev series for the sine wave
+        ctxtEnc = cc->EvalChebyshevSeries(ctxtEnc, coefficients, coeffLowerBound, coeffUpperBound);
+
+        // Double-angle iterations
+        if ((cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY) ||
+            (cryptoParams->GetSecretKeyDist() == SPARSE_TERNARY)) {
+            if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+                algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+            }
+            uint32_t numIter;
+            if (cryptoParams->GetSecretKeyDist() == UNIFORM_TERNARY)
+                numIter = R_UNIFORM;
+            else
+                numIter = R_SPARSE;
+            ApplyDoubleAngleIterations(ctxtEnc, numIter);
+        }
+
+        // scale the message back up after Chebyshev interpolation
+        algo->MultByIntegerInPlace(ctxtEnc, scalar);
+
+#ifdef BOOTSTRAPTIMING
+        timeModReduce = TOC(t);
+
+        std::cerr << "Approximate modular reduction time: " << timeModReduce / 1000.0 << " s" << std::endl;
+
+        // Running SlotToCoeff
+
+        TIC(t);
+#endif
+
+        //------------------------------------------------------------------------------
+        // Running SlotsToCoeffs
+        //------------------------------------------------------------------------------
+
+        // In the case of FLEXIBLEAUTO, we need one extra tower
+        // TODO: See if we can remove the extra level in FLEXIBLEAUTO
+        if (cryptoParams->GetScalingTechnique() != FIXEDMANUAL) {
+            algo->ModReduceInternalInPlace(ctxtEnc, BASE_NUM_LEVELS_TO_DROP);
+        }
+
+        return ctxtEnc;
+
+        // linear transform for decoding
+        ctxtDec = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0Pre, ctxtEnc) :
+                                    EvalSlotsToCoeffs(precom->m_U0PreFFT, ctxtEnc);
+
+        cc->EvalAddInPlace(ctxtDec, cc->EvalRotate(ctxtDec, slots));
+    }
+
+#if NATIVEINT != 128
+    // 64-bit only: scale back the message to its original scale.
+    uint64_t corFactor = (uint64_t)1 << std::llround(correction);
+    algo->MultByIntegerInPlace(ctxtDec, corFactor);
+#endif
+
+#ifdef BOOTSTRAPTIMING
+    timeDecode = TOC(t);
+
+    std::cout << "Decoding time: " << timeDecode / 1000.0 << " s" << std::endl;
+#endif
+
+    auto bootstrappingNumTowers = ctxtDec->GetElements()[0].GetNumOfElements();
+
+    // If we start with more towers, than we obtain from bootstrapping, return the original ciphertext.
+    if (bootstrappingNumTowers <= initSizeQ) {
+        return ciphertext->Clone();
+    }
+
+    return ctxtDec;
+}
+
 Ciphertext<DCRTPoly> FHECKKSRNS::EvalBootstrap(ConstCiphertext<DCRTPoly> ciphertext, uint32_t numIterations,
                                                uint32_t precision) const {
     const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ciphertext->GetCryptoParameters());
@@ -442,6 +1497,7 @@ Ciphertext<DCRTPoly> FHECKKSRNS::EvalBootstrap(ConstCiphertext<DCRTPoly> ciphert
     auto elementParamsRaisedPtr = std::make_shared<ILDCRTParams<DCRTPoly::Integer>>(M, moduli, roots);
 
     NativeInteger q = elementParamsRaisedPtr->GetParams()[0]->GetModulus().ConvertToInt();
+
     double qDouble  = q.ConvertToDouble();
 
     const auto p = cryptoParams->GetPlaintextModulus();
@@ -482,7 +1538,9 @@ Ciphertext<DCRTPoly> FHECKKSRNS::EvalBootstrap(ConstCiphertext<DCRTPoly> ciphert
     for (size_t i = 0; i < ctxtDCRT.size(); i++) {
         DCRTPoly temp(elementParamsRaisedPtr, COEFFICIENT);
         ctxtDCRT[i].SetFormat(COEFFICIENT);
+
         temp = ctxtDCRT[i].GetElementAtIndex(0);
+
         temp.SetFormat(EVALUATION);
         ctxtDCRT[i] = temp;
     }
@@ -514,7 +1572,6 @@ Ciphertext<DCRTPoly> FHECKKSRNS::EvalBootstrap(ConstCiphertext<DCRTPoly> ciphert
     }
 
     double constantEvalMult = pre * (1.0 / (k * N));
-
     cc->EvalMultInPlace(raised, constantEvalMult);
 
     // no linear transformations are needed for Chebyshev series as the range has been normalized to [-1,1]
@@ -541,6 +1598,8 @@ Ciphertext<DCRTPoly> FHECKKSRNS::EvalBootstrap(ConstCiphertext<DCRTPoly> ciphert
         // need to call internal modular reduction so it also works for FLEXIBLEAUTO
         algo->ModReduceInternalInPlace(raised, BASE_NUM_LEVELS_TO_DROP);
 
+        //return raised;
+
         // only one linear transform is needed as the other one can be derived
         auto ctxtEnc = (isLTBootstrap) ? EvalLinearTransform(precom->m_U0hatTPre, raised) :
                                          EvalCoeffsToSlots(precom->m_U0hatTPreFFT, raised);
@@ -690,7 +1749,6 @@ Ciphertext<DCRTPoly> FHECKKSRNS::EvalBootstrap(ConstCiphertext<DCRTPoly> ciphert
                 numIter = R_SPARSE;
             ApplyDoubleAngleIterations(ctxtEnc, numIter);
         }
-
         // scale the message back up after Chebyshev interpolation
         algo->MultByIntegerInPlace(ctxtEnc, scalar);
 
@@ -983,7 +2041,7 @@ std::vector<int32_t> FHECKKSRNS::FindSlotsToCoeffsRotationIndices(uint32_t slots
 
 std::vector<ConstPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
     const CryptoContextImpl<DCRTPoly>& cc, const std::vector<std::vector<std::complex<double>>>& A, double scale,
-    uint32_t L) const {
+    uint32_t L, bool extended) const {
     if (A[0].size() != A.size()) {
         OPENFHE_THROW("The matrix passed to EvalLTPrecompute is not square");
     }
@@ -1023,7 +2081,7 @@ std::vector<ConstPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
     auto paramsQ = elementParams.GetParams();
     usint sizeQ  = paramsQ.size();
     auto paramsP = cryptoParams->GetParamsP()->GetParams();
-    usint sizeP  = paramsP.size();
+    usint sizeP  = extended ? paramsP.size() : 0;
 
     std::vector<NativeInteger> moduli(sizeQ + sizeP);
     std::vector<NativeInteger> roots(sizeQ + sizeP);
@@ -1057,6 +2115,11 @@ std::vector<ConstPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
 
                 result[bStep * j + i] =
                     MakeAuxPlaintext(cc, elementParamsPtr, Rotate(diag, offset), 1, towersToDrop, diag.size());
+
+                if(!extended) {
+                    result[bStep * j + i] =
+                        cc.MakeCKKSPackedPlaintext(Rotate(diag, offset), 1, towersToDrop, nullptr, diag.size());
+                }
             }
         }
     }
@@ -1065,7 +2128,7 @@ std::vector<ConstPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
 
 std::vector<ConstPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
     const CryptoContextImpl<DCRTPoly>& cc, const std::vector<std::vector<std::complex<double>>>& A,
-    const std::vector<std::vector<std::complex<double>>>& B, uint32_t orientation, double scale, uint32_t L) const {
+    const std::vector<std::vector<std::complex<double>>>& B, uint32_t orientation, double scale, uint32_t L, bool extended) const {
     uint32_t slots = A.size();
 
     auto pair = m_bootPrecomMap.find(slots);
@@ -1100,8 +2163,10 @@ std::vector<ConstPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
 
     auto paramsQ = elementParams.GetParams();
     usint sizeQ  = paramsQ.size();
+
+
     auto paramsP = cryptoParams->GetParamsP()->GetParams();
-    usint sizeP  = paramsP.size();
+    usint sizeP  = extended ? paramsP.size() : 0;
 
     std::vector<NativeInteger> moduli(sizeQ + sizeP);
     std::vector<NativeInteger> roots(sizeQ + sizeP);
@@ -1122,7 +2187,7 @@ std::vector<ConstPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
 
     if (orientation == 0) {
         // vertical concatenation - used during homomorphic encoding
-        // #pragma omp parallel for
+#pragma omp parallel for
         for (int j = 0; j < gStep; j++) {
             int offset = -bStep * j;
             for (int i = 0; i < bStep; i++) {
@@ -1134,8 +2199,15 @@ std::vector<ConstPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
                     for (uint32_t k = 0; k < vecA.size(); k++)
                         vecA[k] *= scale;
 
+
                     result[bStep * j + i] =
-                        MakeAuxPlaintext(cc, elementParamsPtr, Rotate(vecA, offset), 1, towersToDrop, vecA.size());
+                            MakeAuxPlaintext(cc, elementParamsPtr, Rotate(vecA, offset), 1, towersToDrop, vecA.size());
+
+                    if(!extended) {
+
+                        result[bStep * j + i] =
+                            cc.MakeCKKSPackedPlaintext(Rotate(vecA, offset), 1, towersToDrop, elementParamsPtr, vecA.size());
+                    }
                 }
             }
         }
@@ -1162,8 +2234,16 @@ std::vector<ConstPlaintext> FHECKKSRNS::EvalLinearTransformPrecompute(
                     for (uint32_t k = 0; k < vec.size(); k++)
                         vec[k] *= scale;
 
+
                     result[bStep * j + i] =
-                        MakeAuxPlaintext(cc, elementParamsPtr, Rotate(vec, offset), 1, towersToDrop, vec.size());
+                            MakeAuxPlaintext(cc, elementParamsPtr, Rotate(vec, offset), 1, towersToDrop, vec.size());
+
+
+                    if(!extended) {
+
+                        result[bStep * j + i] =
+                            cc.MakeCKKSPackedPlaintext(Rotate(vec, offset), 1, towersToDrop, nullptr, vec.size());
+                    }
                 }
             }
         }
@@ -1603,7 +2683,14 @@ Ciphertext<DCRTPoly> FHECKKSRNS::EvalLinearTransform(const std::vector<ConstPlai
 
     Ciphertext<DCRTPoly> result;
     DCRTPoly first;
+    // Q_l -> Q_0 -> Q_L   ||  ModUp := Q_l -> Q_l*P   (Q_l -> Q * P)
+
+    // vector<Paintext> A -> 2^4 * ( N * (L + (K) ) ~ 32 ) * 8 -> 2^28 -> 256 MB + 64 MB
 
+    // ModDown bStep times (extra) bStep = 4, gStep = 4
+    //
+    // ModUp 1 , KeySwitch (bStep), ptMult + hAdd (2^4 = bStep * gStep), gStep-1 (moddown -> rotation)
+    // ModUp 1 , KeySwitch (bStep), ModDown (bStep), ptMult + hAdd (2^4 = bStep * gStep), (gStep-1) ( rotation -> moddown)
     for (uint32_t j = 0; j < gStep; j++) {
         Ciphertext<DCRTPoly> inner = EvalMultExt(cc->KeySwitchExt(ct, true), A[bStep * j]);
         for (uint32_t i = 1; i < bStep; i++) {
@@ -1634,7 +2721,7 @@ Ciphertext<DCRTPoly> FHECKKSRNS::EvalLinearTransform(const std::vector<ConstPlai
     }
 
     result        = cc->KeySwitchDown(result);
-    auto elements = result->GetElements();
+    auto elements= result->GetElements();
     elements[0] += first;
     result->SetElements(std::move(elements));
 
@@ -2135,7 +3222,7 @@ void FHECKKSRNS::AdjustCiphertext(Ciphertext<DCRTPoly>& ciphertext, double corre
     }
 }
 
-void FHECKKSRNS::ApplyDoubleAngleIterations(Ciphertext<DCRTPoly>& ciphertext, uint32_t numIter) const {
+void FHECKKSRNS::ApplyDoubleAngleIterations(Ciphertext<DCRTPoly>& ciphertext, uint32_t numIter) {
     auto cc = ciphertext->GetCryptoContext();
 
     int32_t r = numIter;
@@ -2146,6 +3233,7 @@ void FHECKKSRNS::ApplyDoubleAngleIterations(Ciphertext<DCRTPoly>& ciphertext, ui
         cc->EvalAddInPlace(ciphertext, scalar);
         cc->ModReduceInPlace(ciphertext);
     }
+
 }
 
 #if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
@@ -2306,6 +3394,9 @@ Plaintext FHECKKSRNS::MakeAuxPlaintext(const CryptoContextImpl<DCRTPoly>& cc, co
     Plaintext p = Plaintext(std::make_shared<CKKSPackedEncoding>(params, cc.GetEncodingParams(), value, noiseScaleDeg,
                                                                  level, scFact, slots));
 
+
+
+
     DCRTPoly& plainElement = p->GetElement<DCRTPoly>();
 
     usint N = cc.GetRingDimension();
@@ -2453,6 +3544,7 @@ Plaintext FHECKKSRNS::MakeAuxPlaintext(const CryptoContextImpl<DCRTPoly>& cc, co
     p->SetFormat(Format::EVALUATION);
     p->SetScalingFactor(pow(p->GetScalingFactor(), noiseScaleDeg));
 
+
     return p;
 }
 #endif
@@ -2524,7 +3616,6 @@ Ciphertext<DCRTPoly> FHECKKSRNS::Conjugate(ConstCiphertext<DCRTPoly> ciphertext,
     algo->KeySwitchInPlace(result, evalKeyMap.at(2 * N - 1));
 
     std::vector<DCRTPoly>& rcv = result->GetElements();
-
     rcv[0] = rcv[0].AutomorphismTransform(2 * N - 1, vec);
     rcv[1] = rcv[1].AutomorphismTransform(2 * N - 1, vec);
 
diff --git a/src/pke/lib/scheme/ckksrns/ckksrns-leveledshe.cpp b/src/pke/lib/scheme/ckksrns/ckksrns-leveledshe.cpp
index d25ee6f9..714c4cfd 100644
--- a/src/pke/lib/scheme/ckksrns/ckksrns-leveledshe.cpp
+++ b/src/pke/lib/scheme/ckksrns/ckksrns-leveledshe.cpp
@@ -512,6 +512,7 @@ void LeveledSHECKKSRNS::MultByIntegerInPlace(Ciphertext<DCRTPoly>& ciphertext, u
 
 void LeveledSHECKKSRNS::AdjustLevelsAndDepthInPlace(Ciphertext<DCRTPoly>& ciphertext1,
                                                     Ciphertext<DCRTPoly>& ciphertext2) const {
+
     const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ciphertext1->GetCryptoParameters());
     usint c1lvl             = ciphertext1->GetLevel();
     usint c2lvl             = ciphertext2->GetLevel();
diff --git a/src/pke/lib/scheme/ckksrns/ckksrns-utils.cpp b/src/pke/lib/scheme/ckksrns/ckksrns-utils.cpp
index da0eeff9..a8664b0f 100644
--- a/src/pke/lib/scheme/ckksrns/ckksrns-utils.cpp
+++ b/src/pke/lib/scheme/ckksrns/ckksrns-utils.cpp
@@ -814,34 +814,40 @@ std::vector<int32_t> GetCollapsedFFTParams(uint32_t slots, uint32_t levelBudget,
     uint32_t numRotationsRem = (1 << (remCollapse + 1)) - 1;
 
     // Computing the baby-step b and the giant-step g for the collapsed layers for decoding.
+    /** For GPU execution: smaller bStep*/
     int32_t g;
     if (dim1 == 0 || dim1 > numRotations) {
         if (numRotations > 7) {
             g = (1 << (int32_t(layersCollapse / 2) + 2));
+            //g = 1 << (((int)log2(numRotations) + 1) / 2 + 1);
         }
         else {
-            g = (1 << (int32_t(layersCollapse / 2) + 1));
+            //g = (1 << (int32_t(layersCollapse / 2) + 1));
+            g = numRotations;
         }
     }
     else {
         g = dim1;
     }
-    int32_t b = (numRotations + 1) / g;
+    int32_t b = (numRotations + g - 1) / g;
 
     int32_t bRem = 0;
     int32_t gRem = 0;
     if (flagRem) {
         if (numRotationsRem > 7) {
+
             gRem = (1 << (int32_t(remCollapse / 2) + 2));
+            //gRem = 1 << (((int)log2(numRotationsRem) + 1) / 2 + 1);
         }
         else {
-            gRem = (1 << (int32_t(remCollapse / 2) + 1));
+            //gRem = (1 << (int32_t(remCollapse / 2) + 1));
+            gRem = numRotationsRem;
         }
-        bRem = (numRotationsRem + 1) / gRem;
+        bRem = (numRotationsRem + gRem - 1) / gRem;
     }
 
     // If this return statement changes then CKKS_BOOT_PARAMS should be altered as well
-    return {int32_t(levelBudget),     layersCollapse, remCollapse, int32_t(numRotations), b, g,
+    return { int32_t(levelBudget),     layersCollapse, remCollapse, int32_t(numRotations), b, g,
             int32_t(numRotationsRem), bRem,           gRem};
 }
 
diff --git a/src/pke/lib/schemebase/base-leveledshe.cpp b/src/pke/lib/schemebase/base-leveledshe.cpp
index 29f0cf90..09eabb25 100644
--- a/src/pke/lib/schemebase/base-leveledshe.cpp
+++ b/src/pke/lib/schemebase/base-leveledshe.cpp
@@ -205,7 +205,7 @@ Ciphertext<Element> LeveledSHEBase<Element>::EvalMult(ConstCiphertext<Element> c
     std::vector<Element>& cv = ciphertext->GetElements();
     for (auto& c : cv)
         c.SetFormat(Format::EVALUATION);
-
+    // Certified up to here
     auto algo = ciphertext->GetCryptoContext()->GetScheme();
 
     std::shared_ptr<std::vector<Element>> ab = algo->KeySwitchCore(cv[2], evalKey);
@@ -402,7 +402,8 @@ std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> LeveledSHEBase<Element>::E
         (*evalKeys)[indx];
     }
     size_t sz = indexList.size();
-#pragma omp parallel for if (sz >= 4)
+    /* FIDESlib change */
+    //#pragma omp parallel for if (sz >= 4)
     for (size_t i = 0; i < sz; ++i) {
         PrivateKey<Element> privateKeyPermuted = std::make_shared<PrivateKeyImpl<Element>>(cc);
 
diff --git a/src/pke/unittest/utils/BaseTestCase.h b/src/pke/unittest/utils/BaseTestCase.h
index f392caca..f9bdd995 100644
--- a/src/pke/unittest/utils/BaseTestCase.h
+++ b/src/pke/unittest/utils/BaseTestCase.h
@@ -44,7 +44,7 @@
 #include <vector>
 
 struct BaseTestCase {
-private:
+public:
     // std::shared_ptr<lbcrypto::Params> params;
     lbcrypto::SCHEME scheme;
     std::vector<std::string> paramOverrides;
diff --git a/third-party/google-benchmark b/third-party/google-benchmark
index e451e50e..4e26a9e6 160000
--- a/third-party/google-benchmark
+++ b/third-party/google-benchmark
@@ -1 +1 @@
-Subproject commit e451e50e9b8af453f076dec10bd6890847f1624e
+Subproject commit 4e26a9e6eedb3e89c448cf7115352cb085fdb713
diff --git a/third-party/google-test b/third-party/google-test
index 8b4817e3..279f8479 160000
--- a/third-party/google-test
+++ b/third-party/google-test
@@ -1 +1 @@
-Subproject commit 8b4817e3df3746a20502a84580f661ac448821be
+Subproject commit 279f8479469d22fa772adb454068f854472e1eb9
diff --git a/third-party/gperftools b/third-party/gperftools
index c1d546d7..f9fb817b 160000
--- a/third-party/gperftools
+++ b/third-party/gperftools
@@ -1 +1 @@
-Subproject commit c1d546d7b22cc503f37e9a6efa1d249be60243a3
+Subproject commit f9fb817bef1a17a401ca5ca605fec4627a4a6736
-- 
2.43.0

